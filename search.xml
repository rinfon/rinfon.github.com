<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[那些年，我们一起做过的Android优化]]></title>
    <url>%2F2019%2F05%2F18%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E5%81%9A%E8%BF%87%E7%9A%84Android%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[“那些年，我们一起做过的Android优化” 是由六把斧编剧，Android studio监制，AS调试技巧、卡顿优化、内存优化、耗电优化等改编的小说，讲述了程序猿和Android优化之间令人操蛋的恩怨情仇。 上面都是瞎几把说的。这系列主要分为一下四个方面来说 AS调试的技巧 卡顿优化 内存优化 耗电优化 由于篇幅过长，本文先分享AS调试技巧 AS调试技巧无需再次编译直接进入debug模式刚毕业的时候开始工作的时候，接手了一个代码量10万级以上的项目，重点是项目没有模块化，加上当时配的电脑渣，每次编译都想屎想屎，每次编译都30分钟以上。简直爽得不要不要的，咱也不懂，咱也不敢问啊。 某天正常debug项目的时候 旁边的小黄跟我说，你™在干什么，你这样编译到什么时候，直接Attach Process就可以啦。从此debug爽得不要不要的 条件断点 先进行普通的断点，然后对着断点右键，设置好条件即可，注意一下Suspend的选择 变量的断点 有时候我们需要知道一个变量哪里被访问，哪里被修改。这个时候我们就可以使用变量断点。对着要跟踪的变量打断点即可，注意一下watch的类型。 分析数据流如果想知道一个变量，它是如何被传入到当前位置，不要在傻傻的全局搜索啦。对着要跟踪的变量右键-&gt;Analyze-&gt;Analyze data to here,就会在下方显示出所有有可能赋值给它的地方。而Analyze data from here，表示跟踪变量如何传到别的地方。 分析方法、变量的引用对着要分析的方法或者变量右键，Find usages，就会看到项目所有引用到的地方。注意一下，跟上面的分析数据流还是有差别的。 日志断点有时候我们只是需要知道某个变量的值而已，并不想添加log之后重新编译。进行普通的断点，点击More，去掉Suspend，输入需要log的日志或者想知道的变量。甚至可以把Stack trace打印出来。 求值表达式进入debug模式之后，可以直接输入想知道的变量值以及方法的返回值。 修改变量 学会了以上基本的调试技巧，从此修bug不是梦。 接下来我们将进入本系列的高潮部分。卡顿优化、内存优化、耗电优化.]]></content>
      <tags>
        <tag>android</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android模块化实现]]></title>
    <url>%2F2019%2F05%2F16%2FAndroid%E6%A8%A1%E5%9D%97%E5%8C%96%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[简单性和模块化是软件工程的基石；分布式和容错性是互联网的生命。 《Tim Berners-Lee》 什么是模块化个人认为模块化是对整个项目的解耦以及项目维护带来极大的优势。而且在协同开发的导致各种各样的问题（例如文件冲突等问题） 模块化还可以实现模块内自管理，模块内你可以自由发挥你的管理方式，不管你是mvp，mvvm。每个人维护若干个模块。 基本思路之前有阅读微信 Android 模块化架构重构实践，其中提出的pin工程让我眼前一亮，原来还可以这么搞。同时也参考了一下饿了么移动App的架构演进，那么其中的Excalibur系统也是一大亮点。 结合各大厂的架构演进，再加上即将要开展的新项目的情况，最后决定使用接口+SDK方式，进行模块化管理。 为什么不用类似微信的pin工程，原因是如果是要对现有的项目实现模块化，那么pin是一个非常好的过度方案，你无需进行繁杂的模块管理，直接在现有的工程上，以最快最少的方式就可以实现pin工程，最后完成module的转变。但如果我是全新的项目，则接口+模块会是更好的选择。 基本架构图 最底层是Common: 里面主要是核心模块、公共UI模块以及第三方库 apis: 这里存放所有模块的暴露出来的接口 Bridge: 桥接器，里面可以按需进行模块的注册 App: App只依赖Bridge和Apis，模块的实现并不引用。 这样下来，就可以根据需要输出不同的App，特别像那种会进行更换厂商提供的sdk的，或者要求输出不同模块需要单独变成一个App的，简直是天大的福音。 项目结构 首先，我们假设要集成某厂商的摄像头。我们定义一个plugin_camera模块，里面是摄像头具体实现，里面只有一个简单的方法echo 123456public class Camera implements ICamera &#123; @Override public void echo() &#123; Log.i("Camera","echo hello"); &#125;&#125; 同时在Apis里面定义好要暴露的echo方法 123public interface ICamera &#123; void echo();&#125; 然后桥接器里面进行模块的桥接 123456789101112131415161718192021222324252627282930313233343536373839404142public class Bridge &#123; private static final Bridge ourInstance = new Bridge(); public static Bridge getInstance() &#123; return ourInstance; &#125; HashMap&lt;Class, Class&gt; build; private Bridge() &#123; build = new HashMap&lt;Class, Class&gt;();// register(ICamera.class, Camera.class); register(ICamera.class, "com.rinfon.plugin_camera.Camera"); &#125; public Bridge register(Class interfaceClass, Class apiClass) &#123; build.put(interfaceClass, apiClass); return this; &#125; public Bridge register(Class interfaceClass, String apiClassName) &#123; try &#123; Class t = Class.forName(apiClassName); build.put(interfaceClass, t); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return this; &#125; public &lt;T&gt; T plugin(Class&lt;T&gt; type) &#123; try &#123; return (T) build.get(type).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 最后在主app里面直接使用 12Bridge bridge = Bridge.getInstance();bridge.plugin(ICamera.class).echo(); 如果某天产品经理跟你说，需要把Camera单独出来做成一个App，你只需要在plugin_camera模块里面增加对应的mainactivity和对应的Manifest.xml就可以了。 注意事项 上面没有详细说明怎么实现模块App，但原理也很简单，新建模块的时候，你需要把模块内的build.gradle修改成 12345if (!isOpenCamera.toBoolean()) &#123; apply plugin: 'com.android.application'&#125; else &#123; apply plugin: 'com.android.library'&#125; 继续在模块内生成一个debug用的Manifest.xml和release用的Manifest.xml。 然后在根目录下的gradle.properties里面增加以下内容 1isOpenCamera=false 实现具体请看源码吧。 Bridge和Apis其实可以合并成一个模块也是可以的。 Bridge里面的模块注册使用的方式是反射，但这只是为了演示作用，其实如果真的在实际开发过程中，会使用模块自动注册的方式，而且像Demo里面直接反射。如果还用了ARoute的话，那么其中也包含了自动注册。但个人更加倾向的是使用gradle插件，通过操作字节码的方式来实现自动注册的。当然也可以使用AOP的方式来注册。后期会详细说说这几种方式的却别。 用一句网上看到的话来进行总结吧，我觉得非常好笑，也觉得非常的有道理的一句话。 任何软件工程遇到的问题都可以通过增加一个中间层来解决! 项目已上传github]]></content>
      <tags>
        <tag>android</tag>
        <tag>Android架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Apk破解]]></title>
    <url>%2F2019%2F03%2F01%2FAndroid%20Apk%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[自己动手，丰衣足食 工具 MT管理器.apk 开始多年前在iOS上进行过逆向，到现在为止还是无法忘记FLEX带给我的冲击是有多大，强大的方法搜索，丰富的社区破解资源。原来逆向可以这么简单，找到对应的方法(俗称G点)，修改个返回值，各种VIP沾手就来。后来去搞Android的时候，居然没有对应的软件可以实现上述的功能。由于平台的差异，iOS能够获取到运行时内存上的数据，然后进行修改。Android则不行，需要对Apk进行逆向，修改，打包。 1.准备好你要逆向的apk2.在手机上用mt管理器查看apk 3.进去之后选择对应的dex文件查看，或者选择多个dex合并一起来看，我通常都是使用Dex++来把所有的dex打开。4.搜索关键字，isvip，ispro，isbuy等等你能想到的方法名字，通过不断的查看代码，得到G点。对于这个apk的反编译，还得感谢开发者的良好编程习惯。在反编译的过程中，我发现猿哥居然把类的toString完整的输出来了，剩下了很多排查的时间。 5.查看代码 6.最后能够判断出ispro正是此apk来判断是否为vip的方法，那么只需要在对应的地方进行修改即可，强制返回一个true。7.保存，去除签名，重新打包即可。 总结其实上面的例子也没啥营养的，也只是演示了一下apk的破解过程。重点在下面 如文中开头所说，逆向的关键在于G点，如何找到这个G点，就有很大学问了。提供一个思路，仅供参考 第一步，搜索关键字isDebug，通常程序员都会封装一个自己的Log Utils，用于控制日志的开关，release包都会关掉。那么，我们可以通过打开这个开关，接上logcat，你就能看到apk输出所有日志，犹如把apk扒了一成皮。 通过apk里面的返回信息进行关键字的搜索，例如，有些app会提示你升级VIP，或者购买套餐，再或者激活失败等等关键词。来找到G点所在。 找到G点所在以后。就能为所欲为了。 有时候，一些类里面的toString()方法可能会有意想不到的收获 说说防范措施吧 加入签名验证，在apk里面加入对签名文件的验证，先对签名文件md5，然后在程序启动的时候对apk里面的签名进行对比，不一样，则直接退出app，但请注意：不要在java层进行签名的判断，把判断的逻辑放在jni里面去，如果签名不一致，直接so闪退即可。虽说so指标不治本，但是还是能提高破解的难度，在攻与防之间，从来没有说哪一种方法能破解所有的apk，同样也没有任何一种防护措施能一了百了。两者都是互相存在，互相发展。 apk加壳，在现有的加壳服务提供商中选择一家，来直接对apk进行加壳。但是加壳会增加apk的启动时间。 如果你的app跟服务器有关，那么所有的判断逻辑应该在服务器上面，而不是app里面。相信搞服务器的都明白这一点的。例如各种聊天软件的会员，各种音乐软件的会员。你最后破解了vip也还是ziwei版的app。 当你发现你的生活离不开一个App，并且它能带给你效益和创造价值。你应该考虑的是为它补上一个车票，而不是花大量的时间去破解。]]></content>
      <tags>
        <tag>android</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android蓝牙连接问题]]></title>
    <url>%2F2019%2F02%2F23%2FAndroid%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题部分在使用FastBleLib的时候，会出现连接失败错误码为BleException { code=102, description=&#39;GATT discover services exception occurred!&#39;}、或者连接上了，却找不到读写服务。 解决方法 设备蓝牙库的问题，需要更换蓝牙库 在进行蓝牙连接的时候，重连多次 去到系统蓝牙设置页面，手动点击蓝牙配对，然后再回到app内进行蓝牙重连。 其实多数都是因为设备蓝牙库的问题导致，可以尝试连接其他设备的蓝牙，是否会出现相同的问题]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑苹果安装]]></title>
    <url>%2F2019%2F02%2F23%2F%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[##前言之前在我的Macbook Pro里面进行项目编译的时候发现，实在是太慢了。而且还老是编译失败，总感觉哪里出问题了。无奈已经太旧了，并不是很想去碰它。但家里工作需要，想想台式也不能白白浪费。所以就折腾了一下黑苹果。 配置 i5 9600k GTX 1060 6g 技嘉Z360M aorus pro ALC892 安装过程安装过程以及资料参考黑果小兵，由于10.14 N卡驱动不了，所以我装的是10.13。 遇到的问题显卡问题直接使用Nvidia webdriver来驱动，傻白甜的驱动方法，驱动成功后，需要修改efi里面的config.plist，把nvidiaweb勾选中，不然重启后还是使用核显驱动，并且你在mac系统里面去设置是没有用的。 声卡驱动声卡比较麻烦，试过用AppleALC来驱动，不知道我没看懂还是怎么的，反正892声卡的id我都试过一遍，还是驱动不了，最后用了AppleHDA pather来驱动，layoutid选5，最终成功了。注意，EFI的clover/kexts/other/里面一定要有AppleALC.kext，并且系统的s/l/e里面的AppleHDA.kext一定要是没有修改过的睡眠唤醒后没有声音，搜索了一遍也试过一遍所谓的解决方案，均无效，想到日常中我休眠的机会并不多，所以就当没事发生吧😂。 总结声卡的问题卡了好多天才能解决，google也需要艺术才能得到你想要的答案。编译项目也快多了。黑苹果折腾到最后肯定是白苹果 生命不止，折腾不停。]]></content>
      <tags>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自动化测试流程]]></title>
    <url>%2F2019%2F02%2F14%2FAndroid%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言现在基本上项目没有一个完整而且自动化的测试流程，所以总会出现一些低级的，重复的错误。所以需要一个完整完善的自动化测试流程。 Uiautomator2+Pytest+Allureuiautomator2 是一个Android UI自动化框架，支持Python编写测试脚本对设备进行自动化。底层基于Google uiautomator。 特点： 基于uiautomator的模拟点击，触摸事件等 集成模拟输入法输入 集成到网页端的控制 可以不基于app做独立控制，运行流畅 可以通过局域网wifi实现并发测试 限制： 需要python语言基础 pytest一个测试的框架 allure测试报告的输出，具体使用请看官方文档 环境搭建官方Git请自行安装python新建一个测试目录，cd进去，在执行下面的命令准备Python虚拟环境 Virtualenv 12345678pip install virtualenvvirtualenv venv# Linux or Mac. venv/bin/activate# Windowsvenv\Scripts\activate.bat 安装相关的python库 123456789101112131415161718pip install pytest==3.7pip install --upgrade --pre uiautomator2pip install pillowbrew install allure# 注意，pytest-allure-adaptor已经不在维护了，所以我们使用allure-pytest，并且allure-pytest不能与pytest-allure-adaptor同时存在# pip install pytest-allure-adaptorpip install allure-pytest# init 所有的已经连接到电脑的设备python -m uiautomator2 init# 安装webeditorpip install --pre --upgrade weditor# 启动编辑器python -m weditor# 失败重试pip install pytest-rerunfailures 新建一个文件，进行简单测试main.py12345678910def inc(x): return x + 1def test_answer(): assert inc(3) == 5def test_answer2(): assert inc(4) == 5 命令行执行：pytest main.py --alluredir=testreport/之后会在同目录生成一个testreport文件夹allure serve testreport/ 如图所示： fixturefixture作为pytest的精华所在，需要单独的说一下。如果有java的aop基础，那么就很好了解了。其实fixture就是AOP，AOP可以在一个方法执行前后增加一下代码逻辑达到无痛植入。例如日常统计，debug等，而fixture同理。 我能用它做什么？ 每次测试之前，需要清理测试环境，需要检查app的情况。例如解锁手机、清除app数据缓存、打开app、每次测试之后需要关闭app等等操作，都可以通过fixture来实现。]]></content>
      <tags>
        <tag>android</tag>
        <tag>pytest</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Builder模式]]></title>
    <url>%2F2019%2F01%2F21%2FBuilder%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言之前在研究RxJava的时候，就深深的迷上了这种代码调用方式，简洁明了，逻辑也清晰。后台在使用Glide的时候发现这种.调用方法真的很舒服。附上一段代码： 12345Glide.with(this).load(imageUrl).placeholder(image).error(image).into(imageView); 但后来才发现，最好的例子就是Android自带的AlertDialog. 123456789new AlertDialog.Builder(MainActivity.this) .setTitle("One Button") .setMessage("Thanks for visiting The Code of a Ninja - codeofaninja.com") .setPositiveButton("OK", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int id) &#123; dialog.cancel(); &#125; &#125;).show(); 实现现在看一段代码AlertDialog源码1234567891011121314public Person(String name, int sex) &#123; this(name, sex, 0);&#125;public Person(String name, int sex, int age) &#123; this(name,"",age,sex);&#125;public Person(String firstName, String lastName, int age, int sex) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.sex = sex;&#125; person有若干个属性，有三个构造方法。倘若某天person增加了几个字段，然后你就啪啪啪的把这几个字段加在了后面 1234567public Person(String firstName, String lastName, int age, int sex,String arg1,String arg2) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.sex = sex; this.arg1 = arg1; this.arg2 = arg2; 这样看起来就很臃肿，如果参数再多呢，看起来就很难受了。调用的时候还需要去确认每一个位置的参数是什么。两种方式可以解决： Set/Get Builder Set/Get方法的确可以解决。1234567891011121314151617181920212223242526272829public class Person &#123; String name; String lastName; ... public Person(Builder builder) &#123; this.firstName = builder.name; this.lastName = builder.lastName; ... &#125;// 请注意这里返回的是一个Person类而不是void，因为可以链式调用 public Person SetName(String name)&#123; this.name = name; return this; &#125; public String getName()&#123; return this.name; &#125; public Person SetLastName(String lastName)&#123; this.name = lastName; return this; &#125; public String getLastName()&#123; return this.lastName; &#125;&#125; Builder12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Person &#123; String name; String lastName; ... public Person(Builder builder) &#123; this.firstName = builder.name; this.lastName = builder.lastName; ... &#125; // 请注意这里返回的是一个Person类而不是void，因为可以链式调用 public Person SetName(String name)&#123; this.name = name; return this; &#125; public String getName()&#123; return this.name; &#125; public Person SetLastName(String lastName)&#123; this.name = lastName; return this; &#125; public String getLastName()&#123; return this.lastName; &#125; public static class Builder&#123; String name; String lastName; ... public Builder SetName(String name)&#123; this.name = name; return this; &#125; public String getName()&#123; return this.name; &#125; public Builder SetLastName(String lastName)&#123; this.name = lastName; return this; &#125; public String getLastName()&#123; return this.lastName; &#125; public static Builder createBuilder()&#123; return new Builder(); &#125; public Person Build()&#123; return new Person(this); &#125; &#125;&#125; 调用1234Person p = Builder.createBuilder() .SetName("name") .SetLastName("lastname") .Build() 例子有很多，但不变的是思想。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis Docker搭建]]></title>
    <url>%2F2019%2F01%2F17%2FRedis%20Docker%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Docker安装 官网下载Docker 双击安装 Redis安装 命令行执行docker search redis得到结果 安装：docker pull redis:5.0 运行：docker run -p 6379:6379 -v $PWD/data:/data -d redis:3.2 redis-server --appendonly yes -p 6379:6379 : 将容器的6379端口映射到主机的6379端口 -v $PWD/data:/data : 将主机中当前目录下的data挂载到容器的/data redis-server –appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置 查看容器启动情况 docker ps 连接容器 docker exec -it d0347562c1a5 redis-cli]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac升级Python到3.7]]></title>
    <url>%2F2019%2F01%2F16%2FMac%E5%8D%87%E7%BA%A7Python%E5%88%B03.7%2F</url>
    <content type="text"><![CDATA[mac默认的python版本是2.7 下载安装包从官网下载3.7，双击安装。安装完之后python在/Library/Frameworks/Python.framework/Versions/3.7目录下. 修改环境变量vim .bash_profile增加一下代码 1234export PYTHON_HOME=/Library/Frameworks/Python.framework/Versions/3.7export PATH=$PYTHON_HOME/bin:$PATHalias python="/Library/Frameworks/Python.framework/Versions/3.7/bin/python3.7"alias pip="/Library/Frameworks/Python.framework/Versions/3.7/bin/pip3.7" 重新编译一下source .bash_profile 测试命令行输入：python -V和pip --version]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MWeb 自动发布到 Hexo]]></title>
    <url>%2F2019%2F01%2F16%2FMWeb%20%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E5%88%B0%20Hexo%2F</url>
    <content type="text"><![CDATA[需求之前一直在寻找一个合适的方式来记录工作的日常，例如问题记录、方案计划等等。但一直没有找到一直适合自己的工作流程。主要还是卡在记录这一步骤。 记录 -&gt; 记什么、记在哪里、怎么记。 以下将有几百字的废话，赶时间的可以直接下一章节 本项目已经上传到Github，需要的自行下载 为了解决记录问题，我尝试过Eventnote、便签、手写笔记本等等。最后发现都因为各种各样的原因让我放弃了。 Eventnote的编辑器、便签的同步问题、手机笔记本的搜索问题都在阻碍着我记录，知道最近遇到了hexo，才发现原来记录是如此的简单美好。 个人认为一个良好的工作流程应该如下： 接收到需求 计划 实施 记录 归档 计划和记录都可以选择自己喜欢的MarkDown工具，而我自然选择了MWeb，包含了所有该有的功能，查询，文件库管理以及图床功能。 MWeb进行日常的编写查询归档等功能，写好了之后用Alfred把指定的文章post到Hexo,其实也就是执行个脚本，把选中的MD处理一下，变成Hexo格式，然后就可以Post了，同时文件库用坚果云来进行同步。当然，你也可以选择其他的同步软件，例如iCould`Google Drive`等等。 可能有人疑惑，为什么不直接把MWeb的文件库改到Hexo的Post里面去，这样就可以直接编辑Hexo new出来的文件了啊。 正常新建的MWeb文件如图所示：包含了标题，还有内容但直接打开Hexo的MD，就会看不到Title，效果如图所示:虽然我不是处女座，但也忍受不了整个文件库里面都是这种—的标题显示，如果能接受的，你就可以直接用这种方式来处理了。 所以需求总结起来有以下几点。 新建文章 查询文章 增加Tag功能 自动发布到某篇文章到Hexo 新建文章本来计划通过Alfred进行新建文章功能，查询了一下MWeb数据库由于不知道文章ID的生成规则（只知道应该是用时间戳来标识文章ID的，但位数不对，多了4位），所以不敢轻易的往里面插入数据。如果以后有这样的需求，再增加这个功能进去吧。 查询文章具体实现参考了Github-MWeb-Alfred主要也是通过查询数据库来实现的。具体可看原作者的Github-MWeb-Alfred 增加Tag功能通过查看MWeb数据库可以得知，要得到一个文章的所有tag，则需要连表查询，具体的sqlite 语句如下1SELECT b.name FROM tag_article a,tag b WHERE ( a.aid='$&#123;fileid&#125;' AND a.rid = b.id); 完整bash代码:searchtag.sh 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/bin/bash# DESCRIPTION: 将查询出来的md，进行二次查询，把tag汇总，输出tag1,tag2,...# 环境变量和目录检查if [ -z "$&#123;MDOC_HOME&#125;" ];then echo "&#123; \"items\":[" echo "&#123;" echo "\"type\": \"error\"," echo "\"title\": \"请设置环境变量MDOC_HOME\"" echo "&#125;" echo "]&#125;" exit 1fiMDOC_HOME=$(eval "echo $&#123;MDOC_HOME&#125;")if [ ! -d "$&#123;MDOC_HOME&#125;/docs" ];then echo "&#123; \"items\":[" echo "&#123;" echo "\"type\": \"error\"," echo "\"title\": \"\\\"$&#123;MDOC_HOME&#125;/docs\\\" 目录不存在\"" echo "&#125;" echo "]&#125;" exit 1ficd "$&#123;MDOC_HOME&#125;/docs" params="$&#123;1&#125;" # md文章idIFS=';' read -r -a array &lt;&lt;&lt; "$&#123;1&#125;"fileid="$&#123;array[0]&#125;"fileid="$&#123;fileid/.md/&#125;"title="$&#123;array[1]&#125;"taglist=""# 输出文档列表的函数output_result()&#123; if [ "$&#123;files&#125;" = "" ];then echo "$&#123;MDOC_HOME&#125;/docs/$&#123;fileid&#125;.md;$&#123;title&#125;;" exit fi for i in $&#123;files&#125; do if [ "$&#123;taglist&#125;" = "" ];then taglist="$&#123;i&#125;" else taglist="$&#123;taglist&#125;","$&#123;i&#125;" fi done echo "$&#123;MDOC_HOME&#125;/docs/$&#123;fileid&#125;.md;$&#123;title&#125;;$&#123;taglist&#125;" exit&#125;sql="SELECT b.name FROM tag_article a,tag b WHERE ( a.aid='$&#123;fileid&#125;' AND a.rid = b.id);"final_expr="sqlite3 \"$&#123;MDOC_HOME&#125;/mainlib.db\" \"$&#123;sql&#125;\""final_expr="$&#123;final_expr&#125;"# echo "$final_expr"files=`eval "$&#123;final_expr&#125;"`output_result 自动发布某篇文章到Hexo搜索文章-&gt;查询文章所有的tag-&gt;增加Hexo能识别的内容-&gt;发布我在原作者的查询里面修改了一下，因为查询出来的结果是/Users/rinfon/Desktop/work/workstyle/blogfile/docs/15471063755188.md这种路径的，而我需要一个文章的id和文章的title即可15471063755188;title，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#!/bin/bash# NOTE: 本脚本要求所有参数用'或"合成一个参数，如 -t TODO 要输入为 '-t TODO' 或 "-t TODO"# alfred 会将所有输入作为一个参数，包括末尾的空格# 环境变量和目录检查if [ -z "$&#123;MDOC_HOME&#125;" ];then echo "&#123; \"items\":[" echo "&#123;" echo "\"type\": \"error\"," echo "\"title\": \"请设置环境变量MDOC_HOME\"" echo "&#125;" echo "]&#125;" exit 1fiMDOC_HOME=$(eval "echo $&#123;MDOC_HOME&#125;")if [ ! -d "$&#123;MDOC_HOME&#125;/docs" ];then echo "&#123; \"items\":[" echo "&#123;" echo "\"type\": \"error\"," echo "\"title\": \"\\\"$&#123;MDOC_HOME&#125;/docs\\\" 目录不存在\"" echo "&#125;" echo "]&#125;" exit 1ficd "$&#123;MDOC_HOME&#125;/docs"declare -a tag_arr # 标签数组declare -a header_arr # 标题数组declare -a category_arr # 分类数组declare -a keyword_arr # 关键字数组next_input=0 # 下一步输入参数归类，0:keyword, 1: tag, 2: header, 3: categorylast_input=0 # 最后一次输入的参数归类；与next_input 相同end_option=1 # 是否终止了除 keyword 以外类型的参数输入: 单最后一个字符为空格表示输出完成了end_char="" # 最后一个参数最后输入的字符# 收集参数的函数：# 1.收集tag,header,keyword参数，分别放到 tag_arr,header_arr,keyword_arr中# 2.判断用户一下个要输入的参数(next_input)get_params()&#123; while [ $# -gt 0 ]; do case "$1" in -t)# echo "$1" next_input=1 last_input=$&#123;next_input&#125; shift;; -h)# echo "$1" next_input=2 last_input=$&#123;next_input&#125; shift;;# -c|--category)# echo "$1"# next_input=3# last_input=$&#123;next_input&#125;# shift;; *)# echo "$1" str=$&#123;1//，/,&#125; # 中文逗号改成英文逗号 n=$&#123;#str&#125; end_char=$&#123;str:$((n-1))&#125; # 记录最后一个字符 # 按照 next_input 指示，将参数放到对应的数组中。 case "$&#123;next_input&#125;" in 1) IFS=","; for i in $&#123;str&#125;;do tag_arr+=("$i"); done;unset IFS ;; 2) IFS=","; for i in $&#123;str&#125;;do header_arr+=("$i"); done;unset IFS ;; 3) IFS=","; for i in $&#123;str&#125;;do category_arr+=("$i"); done;unset IFS ;; *) keyword_arr+=("$str") ;; esac last_input=$&#123;next_input&#125; # 保存最后一次输入的参数类型 next_input=0; shift;; esac done&#125;get_params $* # 调用收集参数的函数#echo tag_arr=$&#123;tag_arr[@]&#125;#echo header_arr=$&#123;header_arr[@]&#125;#echo category_arr=$&#123;category_arr[@]&#125;#echo keyword_arr=$&#123;keyword_arr[@]&#125;#echo next_input=$&#123;next_input&#125;#echo last_input=$&#123;last_input&#125;# 输出tag列表的函数output_tags()&#123; if [ "$&#123;filtered_tags&#125;" = "" ];then echo "&#123;\"items\":[" echo "&#123;" echo "\"title\": \"没有相关tag\"," echo "&#125;" echo "]&#125;" exit fi local separator="" echo "&#123;\"items\":[" for i in $&#123;filtered_tags&#125; do printf '%s' $&#123;separator&#125; separator="," echo "&#123;" echo "\"title\": \"tag: $&#123;i&#125;\"," echo "\"autocomplete\": \"$&#123;1&#125;$&#123;i&#125;,\"," echo "\"valid\":\"no\"" echo "&#125;" done echo "]&#125;" exit&#125;# 输出文档列表的函数output_files()&#123; if [ "$&#123;files&#125;" = "" ];then echo "&#123;\"items\":[" echo "&#123;" echo "\"title\": \"没有找到符合条件的文档\"," echo "&#125;" echo "]&#125;" exit fi local separator="" echo "&#123;\"items\":[" for i in $&#123;files&#125; do printf '%s' $&#123;separator&#125; separator="," h="$(head -1 "$&#123;i&#125;"| sed 's/\\/\\\\/g;s/"/\\"/g;s/[[:space:]]*$//g')" echo "&#123;" echo "\"type\": \"file\"," echo "\"title\": \"$&#123;h&#125;\"," echo "\"arg\": \"$i;$h\"" echo "&#125;" done echo "]&#125;"&#125;# 最后一个字符不是空格，且最后一次输入归类不是0，这表示该类型参数没有输入完成 --&gt; 可以输出该类型选项if [ "$*" = "$&#123;*% &#125;" -a $&#123;last_input&#125; -gt 0 ];then end_option=0# 下一个参数类型=最后一次输入类型，且类型不是0，表示该类型参数没有输入完成 --&gt; 可以输出该类型选项elif [ $&#123;next_input&#125; -gt 0 -a $&#123;last_input&#125; = $&#123;next_input&#125; ];then end_option=0else end_option=1fi#echo "end_option=$&#123;end_option&#125;"## 如果当前输入为 tag，且没有结束输入，输出tag列表: 排除已经输入的tag，以当前输入为前缀的tagif [ $&#123;last_input&#125; -eq 1 -a $&#123;end_option&#125; -eq 0 ]; then autocomplete='' n=$&#123;#tag_arr[@]&#125; if [ $&#123;n&#125; -eq 0 ];then # 还没有输入任何值 autocomplete="$1 " sql="select name from tag"; elif [ "$&#123;end_char&#125;" = "," ];then # 已输入若干个值，且最后一个值已确定 autocomplete="$1" sql="select name from tag where 1=1"; for i in $&#123;tag_arr[@]&#125; do sql="$&#123;sql&#125; and name not like '$&#123;i&#125;'" done else # 已输入若干个值，且最后一个值还没有输入完成 n=$((n-1)) autocomplete="$&#123;1%$&#123;tag_arr[$&#123;n&#125;]&#125;&#125;" sql="select name from tag where name like '$&#123;tag_arr[@]:$n&#125;%'"; for i in $&#123;tag_arr[@]:0:$&#123;n&#125;&#125; do sql="$&#123;sql&#125; and name not like '$&#123;i&#125;'" done fi# echo $&#123;sql&#125; final_expr="sqlite3 \"$&#123;MDOC_HOME&#125;/mainlib.db\" \"$&#123;sql&#125;\"" filtered_tags=`eval "$&#123;final_expr&#125;"` output_tags "$&#123;autocomplete&#125;" exitfi## 如果有输入-t参数，过滤文档tag## 查询文档SQL:##SELECT a.aid FROM tag_article a,article b##WHERE a.aid = b.uuid AND## a.rid IN (SELECT id from tag b WHERE b.name LIKE 'TODO' or b.name LIKE 'DONE' )##GROUP BY a.aid HAVING count(1) &gt;=2##ORDER BY b.dateModif DESC;if [ $&#123;#tag_arr[@]&#125; -gt 0 ];then sql='select id from tag where ' or_str="" for i in $&#123;tag_arr[@]&#125; do sql="$&#123;sql&#125; $&#123;or_str&#125; name like '$&#123;i&#125;'" or_str=or done sql="SELECT a.aid||'.md' FROM tag_article a,article b \ WHERE a.aid=b.uuid AND a.rid IN ($&#123;sql&#125;) \ GROUP BY a.aid HAVING count(1)&gt;=$&#123;#tag_arr[@]&#125; \ ORDER BY b.dateModif desc";# echo $&#123;sql&#125; final_expr="sqlite3 \"$&#123;MDOC_HOME&#125;/mainlib.db\" \"$&#123;sql&#125;\""else final_expr="ls -t *.md"fi# 如果有输入-h参数，过滤文档标题# 思路: grep -n 会输出行号，找到符合所有关键字的行，筛选行号=1的文档就可以了if [ $&#123;#header_arr[@]&#125; -gt 0 ];then final_expr="$&#123;final_expr&#125; | xargs grep -inHe '$&#123;header_arr[0]&#125;'" for i in $&#123;header_arr[@]:1&#125; do final_expr="$&#123;final_expr&#125; | grep -ie '$&#123;i&#125;'" done final_expr="$&#123;final_expr&#125; | egrep '^.+\.md\:1\:' | awk -F':' '&#123;print \$1&#125;'"fi# 如果有输入关键字，则用关键字筛选文档，并且按照文档标题匹配度排序if [ $&#123;#keyword_arr[@]&#125; -gt 0 ];then for i in $&#123;keyword_arr[@]&#125; do final_expr="$&#123;final_expr&#125;| xargs grep -ile '$&#123;i&#125;' | awk -F':' '&#123;print \$1&#125;' | uniq " done # 排序表达式: 统计第一行匹配关键字个数，将匹配个数大的放在前面 # 第一步: 输入"文件名",输出"文件名 匹配个数" # 第二步: 按照 "匹配个数" 倒序排序 # 第三步: 去掉 "匹配个数" 字段，只保留"文件名" # 由于ls -lt 是按照编辑时间倒序排序的，所以最终排序等级：标题匹配个数倒序-&gt;最后编辑倒序 egrep_expr="$(echo "$&#123;keyword_arr[@]&#125;" | sed "s/[[:blank:]]/|/g")" sort_expr="awk '&#123;system(\"egrep -ioe \\\"$&#123;egrep_expr&#125;\\\" &lt;&lt;&lt; \`head -1 \"\$1 \"\`|wc -l | xargs echo \"\$1)&#125;' | sort -rk 2 | awk '&#123;print \$1&#125;'" final_expr="$&#123;final_expr&#125; | $&#123;sort_expr&#125; "fifinal_expr="$&#123;final_expr&#125; | head -20 " # 限制最多输出20条记录# echo "$final_expr"files=`eval "$&#123;final_expr&#125;"`output_files 为了让Hexo识别，增加了一下脚本1234567891011121314151617181920212223242526272829303132333435363738394041if [ ! -n "$&#123;HEXO_POST&#125;" ] ;then exit 1fiIFS=';' read -r -a array &lt;&lt;&lt; "&#123;query&#125;"path=$&#123;array[0]&#125;title=$&#123;array[1]&#125;title="$&#123;title/\# /&#125;"taglist=$&#123;array[2]&#125;cp "$path" "$&#123;HEXO_POST&#125;/$&#123;title&#125;.md"cd "$&#123;HEXO_POST&#125;"#删除titlesed -i '' 1d ./"$&#123;title&#125;.md"sed -i '' '1i\'$'\n---\n' ./"$&#123;title&#125;.md"sed -i '' "1 a\ title: $title" ./"$&#123;title&#125;.md"sed -i '' "2 a\ tag: [$&#123;taglist&#125;]" ./"$&#123;title&#125;.md"sed -i '' '3 a\'$'\n---\n' ./"$&#123;title&#125;.md"linecount=$(cat ./"$&#123;title&#125;.md" | wc -l )if [ $linecount -gt 11 ];then sed -i '' "12 a\ &lt;!--more--&gt; " ./"$&#123;title&#125;.md"fiPATH=$&#123;HEXO_CMD_PATH&#125;PATH=$&#123;PATH&#125;:$&#123;GIT_PATH&#125;hexo cleanhexo ghexo d 遇到的问题 alfred 执行git、hexo命令找不到问题需要把git的命令路径和hexo路径填写在alfred的环境变量里面。不然执行会git和hexo的操作会失败。]]></content>
      <tags>
        <tag>git</tag>
        <tag>MWeb</tag>
        <tag>Hexo</tag>
        <tag>Alfred</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 项目架构之 MVP]]></title>
    <url>%2F2019%2F01%2F15%2FAndroid%20%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E4%B9%8B%20MVP%2F</url>
    <content type="text"><![CDATA[需求本文不是学术文字讨论（复制粘贴）文，所以不会详细解释什么叫 MVP，MVC，Dagger，Clean 等等。主要以实际项目为基础，简单的实现登录功能。 当代码量越来越大，需要对已有的代码进行整理以及重构，实现解耦. 无论任何的架构模式以及设计模式都是为了代码解耦 研究方向MVP 模式： Model:数据层，主要负责网络数据请求与获取，数据库的处理等等数据相关的逻辑处理 View:视图层，显示数据，例如 Activity,Fragment,View 等等 UI 载体 Presenter:代理层, View 逻辑处理的集合，并且将 Model 获取的数据返回给 View 层 MVP 类型 MVP 简单版 MVP-Clean主要参考实现 Clean Architecture. MVP-DaggerDragger2 的 MVP 实现 MVP-RxJavaRxJava 的 MVP 实现MVP 的简单实现逻辑图 ViewUI 的展示 BasePresenterImpl封装了 View 的处理流程，数据回调等等，例如进行网络请求的时候，loading 的显示与隐藏。 LoginPresenter登录逻辑处理的地方 BaseRespository封装了异常处理，例如网络请求回调的时候，页面消失了，这时候再进行 ui 处理的话就会奔溃。为了不每个页面都加上判空处理，所以就封装了一层。如不需要可以去掉这一层 LoginRespository登录真正执行的地方 关键代码 MainActivity.java 1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends Activity implements IBaseView&lt;String&gt; &#123; LoginPresenter loginPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); loginPresenter = new LoginPresenter(this); loginPresenter.toLogin("111", "111"); &#125; @Override protected void onDestroy() &#123; loginPresenter.unBind(); super.onDestroy(); &#125; @Override public void onSuccess(String Result) &#123; Log.i("MainActivity", Result); &#125; @Override public void onFailed(ErrorCode errorCode) &#123; Log.i("MainActivity", errorCode.getMessage()); String msg = null; msg.toLowerCase(); &#125; @Override public void showProgress() &#123; Log.i("MainActivity", "loading"); &#125; @Override public void hideProgress() &#123; Log.i("MainActivity", "hide loading"); &#125; &#125; LoginPresenter.java 123456789101112131415public class LoginPresenter extends BasePresenterImpl &#123; IBaseRepository baseRepository; public LoginPresenter(IBaseView mView) &#123; super(mView); &#125; public void toLogin(String uid, String password) &#123; mView.showProgress(); baseRepository = LoginRepository.Builder(baseCallback) .setUid(uid).setPassword(password); baseRepository.Action(); &#125; &#125; LoginRepository.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class LoginRepository extends BaseRepository implements IBaseRepository &#123; private String uid; private String password; public static LoginRepository Builder(BaseInteractor.Callback callback) &#123; return new LoginRepository(callback); &#125; public String getUid() &#123; return uid; &#125; public LoginRepository setUid(String uid) &#123; this.uid = uid; return this; &#125; public String getPassword() &#123; return password; &#125; public LoginRepository setPassword(String password) &#123; this.password = password; return this; &#125; public LoginRepository(BaseInteractor.Callback callback) &#123; super(callback); &#125; @Override public void Action() &#123; // TODO // 网络请求 // onRequsetSuccess("login success"); onRequestFailed(new ErrorCode().setStatus(0).setMessage("login fail")); &#125; @Override public void Cancel() &#123; // TODO // 取消网络请求 // 回调上一次进行异常处理 onCancel(); &#125; &#125; 完整代码已经上传到github上去了 -&gt; https://github.com/rinfon/mvp.git MVP-Clean逻辑图 Clean 架构图 时序图就像这篇文章Android 官方架构项目之 MVP + Clean 所说，clean 架构比简单版的 MVP 就是多了一层 Domain 层，减轻 Presenter 的负担。 关键代码 在研究官方的Demo中，有些地方还是值得斟酌的 View 层不通用，例如有些 loading，onSuccess，onError 等通用函数应该抽象到 BaseView 里面去，减少代码量 所有的 Task 都在一开始就在界面初始化好了，如果有些功能我没有用到，那么就浪费资源了，应该改成需要用到的时候再初始化 在 presenter 初始化的时候，View 层传的参数太多了。例如 View 层所有的 task 都要初始化好传进去。个人认为这是不科学的。但后来想官方这样写的原因是为了区分 View 与 Presenter 的职责（看来我还是太年轻了），View 作为数据的提供者，Presenter 作为数据的接受者。所以才不在 Presenter 层新建数据。既然如此，那只需要 Builder 模式就可以解决参数过多的问题了。 Presenter 层 callback 重复代码过多，例如 123456789101112131415mUseCaseHandler.execute(loginTask, new LoginTask.LoginRequestValues(uid, password), new UseCase.UseCaseCallback&lt;BaseResponseValues&gt;() &#123; @Override public void onSuccess(BaseResponseValues response) &#123; mView.closeLoading(); mView.onSuccess(response); &#125; @Override public void onError() &#123; mView.closeLoading(); mView.onFail(); &#125; &#125;); 每次 excute 都需要提供一个 callback，而每个 callback 仅仅 response 的类型不一样而已。流程还是一样的。所以重复代码还是很多。 原本想在 UserCaseHandler 里面增加 View 的持有，从而在 UserCaseHandler 进行 CallBack 的时候把 closeloading 和 onSucces，onFail 都写好，这样就可以解决问题了。 这样的设计方案有个弊端，View 层入侵了 UserCaseHandler，耦合度又增加了。所以看实际需求来权衡吧 来来来，上代码 MvpCleanActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142public class MvpCleanActivity extends Activity implements LoginContract.View&lt;BaseResponseValues&gt; &#123; CleanLoginPresenter loginPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); loginPresenter = new CleanLoginPresenter(this, UseCaseHandler.getInstance(), new LoginTask()); loginPresenter.login("111", "111"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); &#125; @Override public void showLoading() &#123; Log.i("MvpCleanActivity", "showloading"); &#125; @Override public void closeLoading() &#123; Log.i("MvpCleanActivity", "closeloading"); &#125; @Override public void onSuccess(BaseResponseValues r) &#123; Log.i("MvpCleanActivity", r.getResult().getMessage()); // will crash String msg = null; msg.toLowerCase(); &#125; @Override public void onFail() &#123; Log.i("MvpCleanActivity", "login fail"); &#125; CleanLoginPresenter.java 12345678910111213141516171819202122232425262728293031323334public class CleanLoginPresenter implements LoginContract.Presenter &#123; private final LoginContract.View mView; private final UseCaseHandler mUseCaseHandler; private final LoginTask loginTask; public CleanLoginPresenter(LoginContract.View mView, UseCaseHandler mUseCaseHandler, LoginTask loginTask) &#123; // TODO 参数过多，使用 builder 模式 this.mView = mView; this.mUseCaseHandler = mUseCaseHandler; this.loginTask = loginTask; &#125; @Override public void login(String uid, String password) &#123; mView.showLoading(); mUseCaseHandler.execute(loginTask, new LoginTask.LoginRequestValues(uid, password), new UseCase.UseCaseCallback&lt;BaseResponseValues&gt;() &#123; @Override public void onSuccess(BaseResponseValues response) &#123; mView.closeLoading(); mView.onSuccess(response); &#125; @Override public void onError() &#123; mView.closeLoading(); mView.onFail(); &#125; &#125;); &#125; LoginTask.java 123456789101112131415161718192021222324252627public class LoginTask extends UseCase&lt;LoginTask.LoginRequestValues, BaseResponseValues&gt; &#123; @Override protected void executeUseCase(LoginRequestValues requestValues) &#123; // TODO 网络请求 // 回调 getUseCaseCallback().onSuccess(new BaseResponseValues( ResponseEntry .Builder() .setStatus(1) .setMessage("Login success"))); &#125; public static final class LoginRequestValues extends BaseRequsetValues &#123; public LoginRequestValues(@NonNull String uid, @NonNull String password) &#123; super(new HashMap&lt;String, String&gt;()); uid = checkNotNull(uid, "task cannot be null!"); password = checkNotNull(password, "task cannot be null!"); getParmas().put("uid", uid); getParmas().put("password", password); &#125; &#125; &#125; LoginTask 里面跟官方还是不一样的，因为实际需求中，请求的参数和返回的结果结构大多数都是一样的，所以 RequestValues 和 ResponseValues 还是可以封装成公用的。 LoginContract.java 123456789101112131415public class LoginContract &#123; public interface View&lt;T&gt; &#123; void showLoading(); void closeLoading(); void onSuccess(T Result); void onFail(); &#125; public interface Presenter &#123; void login(String uid, String password); &#125; &#125; 就像本文所说，View 层可以再封装成 BaseView，把重复的的代码放进去 UserCase相关的就不放出来了，官方已经封装好了，实际上就是封装了一个线程池，用于异步处理 Task，所以直接使用即可。完整代码已经上传到 github上去了 -&gt; https://github.com/rinfon/mvp.git MVP-Dagger 未完待续 MVP-RxJavaRxJava ，之前我一直很抗拒，因为上手感觉很难，另一部分可能自己心燥，静不下来好好研究。但最近看 MVP-clean 的时候有用到，所以也就铁下心来研究了一下。 本来想写篇文章来分享一下的，但后来看到大神们都已经解释的很清楚，连我都能看懂的，我相信你们都能看懂的。 附上链接 ，小水管 RxJava 通过作者的小水管，我相信你们也会喜欢上 RxJava 的。 回到整体 MVP-RxJava，我看了 google 的 demo 之后，发现其实没什么特别的神的地方（应该是没什么出彩的地方），也就是简单版的 MVP 加上 RxJava 而已，所以 demo 就不放出来了。放出关键代码吧 LoginPresenter.Java 123456789101112131415161718192021222324mCompositeDisposable.add(Observable.create(new ObservableOnSubscribe&lt;User&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;User&gt; e) throws Exception &#123; User user = new User(); user.uid = uid; user.password = password; e.onNext(user); e.onComplete(); &#125; &#125;).subscribeOn(mSchedulerProvider.io()) .observeOn(mSchedulerProvider.ui()) .subscribe(new Consumer&lt;User&gt;() &#123; @Override public void accept(User user) throws Exception &#123; mView.closeLoading(); mView.onSuccess(user); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; mView.closeLoading(); mView.onFail(); &#125; &#125;)); 总结 任何架构设计都是为了解耦，而解耦随之带来的就是代码的增加以及重复 设计的过程中，要注意各层的职责，尽量可以避免入侵 在我的 Demo 中，为了处理回调导致的奔溃，我对回调进行了 try catch，这没有问题，但要对详细的异常进行区分，不能所有的异常都吃掉，这是一种不负责的写法（小孩子不要模范啦）有时候，就应该让它 Crash，才知道问题所在。如果非要吃掉所有的异常，也要封装成一个 ErrorCode，对错误信息进行收集。知乎链接，里面有大牛解释的很清楚了。]]></content>
      <tags>
        <tag>Android架构</tag>
        <tag>MVP</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android studio Jar 包制作以及混淆]]></title>
    <url>%2F2019%2F01%2F12%2F2019-01-12-android%20studio%20Jar%20%E5%8C%85%E5%88%B6%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%B7%B7%E6%B7%86%2F</url>
    <content type="text"><![CDATA[需求 项目越来越大，需要对核心代码进行封装加密管理 Jar 包制作 优点：简单，方便 缺点：不能把资源文件都打进去 Jar 包里面，例如图片，布局文件等等 aar 制作 优点：跟 Jar 一样，可以把资源文件都打包进去，AS可以直接引用，管理方便 缺点：- so 制作 优点：增加反编译难度，核定代码可以放进去 缺点：需要 C/C++基础，并不是所有都适合放到 so 里面去。 实现制作 新建一个 module，选择 Android Library Finish 把你需要封装的代码写在 module 里面去 打包 在 module 里面的 build.gradle 文件加入一下 Task 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748task buildJar(type: Jar, dependsOn: ['compileReleaseJavaWithJavac']) &#123; // task buildJar(type: Jar, dependsOn: ['build'])// 导出的 jar 文件的名称 archiveName = "testJar-debug.jar" //需打包的资源所在的路径集 from('build/intermediates/classes/release') destinationDir = file('../libs') // //导出的 jar 文件的存放目录（未指定则默认存放在 build/libs 下） destinationDir = file('D:/libs') exclude "**/BuildConfig.class" //去掉不要的类 exclude('**/R.class') exclude('**/R\$*.class') include "**/*.*" //需要打包的类 如 // include('com/reginer/mytest/*.class')&#125;task proguardJar(dependsOn: ['buildJar'], type: ProGuardTask) &#123; println('proguard '+project.name+' jar') //Android 默认的 proguard 文件 configuration android.getDefaultProguardFile('proguard-android.txt') //加载各模块 proguard 配置文件 configuration 'proguard-rules.pro' String inJar = buildJar.archivePath.getAbsolutePath() injars inJar outjars inJar.substring(0, inJar.lastIndexOf('-')) + "-release.jar" //设置不删除未引用的资源(类，方法等) dontshrink //运行时 jar 包不混淆 Plugin plugin = getPlugins().hasPlugin(AppPlugin) ? getPlugins().findPlugin(AppPlugin) : getPlugins().findPlugin(LibraryPlugin) if (plugin != null) &#123; List&lt;String&gt; runtimeJarList if (plugin.getMetaClass().getMetaMethod("getRuntimeJarList")) &#123; runtimeJarList = plugin.getRuntimeJarList() &#125; else if (android.getMetaClass().getMetaMethod("getBootClasspath")) &#123; runtimeJarList = android.getBootClasspath() &#125; else &#123; runtimeJarList = plugin.getBootClasspath() &#125; for (String runtimeJar : runtimeJarList) &#123; libraryjars(runtimeJar) &#125; &#125;&#125; 打开 Gradle 任务，执行 buildJar 然后再执行 proguardJar 任务进行混淆 最后你会发现在项目中出现 test-relase.jar 注意buildJar里面archiveName名字必须有-，不然会执行错误的。原因在与在混淆的时候，需要把包名改成 relase.不喜欢的可以自行修改逻辑代码 注意buildJar里面archiveName名字必须有-，不然会执行错误的。原因在与在混淆的时候，需要把包名改成 relase.不喜欢的可以自行修改逻辑代码 注意buildJar里面archiveName名字必须有-，不然会执行错误的。原因在与在混淆的时候，需要把包名改成 relase.不喜欢的可以自行修改逻辑代码]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 found an invalid color]]></title>
    <url>%2F2019%2F01%2F11%2F2019-01-11-%E8%A7%A3%E5%86%B3%20found%20an%20invalid%20color%2F</url>
    <content type="text"><![CDATA[问题在导入 eclipse 项目的时候，有时候会出现 found an invalid color 这个问题，原因在于 AS 对.9 图片的检查 解决方法 图片是.9.png 格式的，但是没有画黑色边框线，需要画上边框线，保存就可以了。或者直接把.9 格式去掉即可]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 的简单介绍]]></title>
    <url>%2F2019%2F01%2F11%2F2019-01-11-git%20%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[git 的简单介绍是什么? Git 是目前世界上最先进的分布式版本控制系统。 为什么 适合分布式开发 速度快，灵活 优秀的解决冲突能力 版本管理 工作流程 克隆项目 修改项目 提交更改 拉取远端最新的更改（如果别人在你修改期间有更改推送过，则需要拉取） 如本地修改跟远端修改有冲突，则解决冲突 重新提交 推送远端 对应流程图如下： 常用命令 git init用于初始化项目 git clone用于克隆项目 git add添加修改文件。其中 git add .代表添加所有修改过的问题件，git add 文件路径,代表添加特定的文件。 git commit提交更改日志，例如 git commit -m “增加功能” git fetch检查远端是否有更改 git pull拉取远端的最新的代码，例如 git pull –rebase.rebase 和 merge 的区别在于：merge 操作会生成一个新的节点，之前的提交分开显示。而 rebase 操作不会生成新的节点，是将两个分支融合成一个线性的提交。所以我们通常 git pull 都会加上 rebase 的参数 git push推送本地更改到服务器,例如 git push orgin master git branch查看当前分支,而如果加上-r 参数，代表查看远程分支 git branch -r git checkout切换分支 例如，git checkout -b develop，切换到 develop 分支，如果本地已经有 develop 分支，则 git checkout develop git tag为节点打日志，例如，我们要为 1b2e1d63ff 打上 1.0 的标签:git tag 1.0 1b2e1d63ff git reset丢弃所有的本地所有的更改，git reset HEAD –hard,同时也可以用此命令回到之前的节点，如果我要返回到上一个节点（注意，此返回指的是你本地返回，而不是远端返回），git reset HEAD^ –hard git status查看本地缓存修改记录 常用技巧现在有 a、b、c、d、e，5 个提交点，我需要切换回滚到 c 节点，丢弃的 d,e 节点git reset HEAD^^ --hard（或者 git reset c 点的 sha 码 --hard） git push origin HEAD --force 把别的分支某个提交点提交到当前分支 例如 develop 上有提交点 a(sha 码为 1b2e1d63ff),需要把 a 也提交到 master 上去. git checkout master git cherry-pick -x 1b2e1d63ff,-x 代表着保留原始作者信息 如果途中产生冲突，则按照标准的解决冲突方法去解决。然后重新 commit 即可 查找某个文件的某行修改记录 新接手了一个项目，里面某一行代码不知道为什么原作者这样写，需要查看对应的提交点记录才能知道为啥当初这样写 例如要查看 a.java 文件的修改记录 git blame **/a.java(注意文件路径),得到如下结果 12345678910^5cdd7bd (Rinfon 2018-04-02 13:14:34 +0800 68) LocalTextView apStepBack;^5cdd7bd (Rinfon 2018-04-02 13:14:34 +0800 69) @BindView(R.id.ap_step_next)^5cdd7bd (Rinfon 2018-04-02 13:14:34 +0800 70) LocalTextView apStepNext;20997902 (Rinfon 2018-06-25 12:03:13 +0800 71) @BindView(R.id.ap_step_three_icon)20997902 (Rinfon 2018-06-25 12:03:13 +0800 72) ImageView apStepThreeIcon;20997902 (Rinfon 2018-06-25 12:03:13 +0800 73) @BindView(R.id.wifi_remember)20997902 (Rinfon 2018-06-25 12:03:13 +0800 74) CheckBox wifiRemember;20997902 (Rinfon 2018-06-25 12:03:13 +0800 75) @BindView(R.id.ap_step_btn_layout)20997902 (Rinfon 2018-06-25 12:03:13 +0800 76) LinearLayout apStepBtnLayout;^5cdd7bd (Rinfon 2018-04-02 13:14:34 +0800 77) private Unbinder unbinder; 这时候已经得到了 sha 码，就可以通过 git show 20997902,可以得到修改的信息。 分支管理主要分支 master 分支。仅且只有一个主分支，用于提供正式版本 develop 分支，开发分支，用于日常开发，如果一个版本开发完整，测试通过，则合并到 develop 里面去。合并的时候需要加上 –no-ff，快进式合并，保证版本的演进清晰。临时分支 feature 分支，当需要做一个新功能时，需要基于 develop 开一个 feature 分支，即使 feature 不完成，也不会影响 develop 的进度. hotfix 分支，用于修改 bug 的分支，基于 master 分出来的。修改结束后，合并到 master 和 develop 上去 但这只是一个基础想法，并不是适用于所有的项目的，而我们需要做的，就是对此策略加以修改，变成适合自己的分支管理。]]></content>
  </entry>
</search>
