<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis Docker搭建]]></title>
    <url>%2F2019%2F01%2F17%2FRedis%20Docker%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Docker安装 官网下载Docker 双击安装 Redis安装 命令行执行docker search redis得到结果 安装：docker pull redis:5.0 运行：docker run -p 6379:6379 -v $PWD/data:/data -d redis:3.2 redis-server --appendonly yes -p 6379:6379 : 将容器的6379端口映射到主机的6379端口 -v $PWD/data:/data : 将主机中当前目录下的data挂载到容器的/data redis-server –appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置 查看容器启动情况 docker ps 连接容器 docker exec -it d0347562c1a5 redis-cli]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac升级Python到3.7]]></title>
    <url>%2F2019%2F01%2F16%2FMac%E5%8D%87%E7%BA%A7Python%E5%88%B03.7%2F</url>
    <content type="text"><![CDATA[mac默认的python版本是2.7 下载安装包从官网下载3.7，双击安装。安装完之后python在/Library/Frameworks/Python.framework/Versions/3.7目录下. 修改环境变量vim .bash_profile增加一下代码 1234export PYTHON_HOME=/Library/Frameworks/Python.framework/Versions/3.7export PATH=$PYTHON_HOME/bin:$PATHalias python="/Library/Frameworks/Python.framework/Versions/3.7/bin/python3.7"alias pip="/Library/Frameworks/Python.framework/Versions/3.7/bin/pip3.7" 重新编译一下source .bash_profile 测试命令行输入：python -V和pip --version]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MWeb 自动发布到 Hexo]]></title>
    <url>%2F2019%2F01%2F16%2FMWeb%20%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E5%88%B0%20Hexo%2F</url>
    <content type="text"><![CDATA[需求之前一直在寻找一个合适的方式来记录工作的日常，例如问题记录、方案计划等等。但一直没有找到一直适合自己的工作流程。主要还是卡在记录这一步骤。 记录 -&gt; 记什么、记在哪里、怎么记。 以下将有几百字的废话，赶时间的可以直接下一章节 本项目已经上传到Github，需要的自行下载 为了解决记录问题，我尝试过Eventnote、便签、手写笔记本等等。最后发现都因为各种各样的原因让我放弃了。 Eventnote的编辑器、便签的同步问题、手机笔记本的搜索问题都在阻碍着我记录，知道最近遇到了hexo，才发现原来记录是如此的简单美好。 个人认为一个良好的工作流程应该如下： 接收到需求 计划 实施 记录 归档 计划和记录都可以选择自己喜欢的MarkDown工具，而我自然选择了MWeb，包含了所有该有的功能，查询，文件库管理以及图床功能。 MWeb进行日常的编写查询归档等功能，写好了之后用Alfred把指定的文章post到Hexo,其实也就是执行个脚本，把选中的MD处理一下，变成Hexo格式，然后就可以Post了，同时文件库用坚果云来进行同步。当然，你也可以选择其他的同步软件，例如iCould`Google Drive`等等。 可能有人疑惑，为什么不直接把MWeb的文件库改到Hexo的Post里面去，这样就可以直接编辑Hexo new出来的文件了啊。 正常新建的MWeb文件如图所示：包含了标题，还有内容但直接打开Hexo的MD，就会看不到Title，效果如图所示:虽然我不是处女座，但也忍受不了整个文件库里面都是这种—的标题显示，如果能接受的，你就可以直接用这种方式来处理了。 所以需求总结起来有以下几点。 新建文章 查询文章 增加Tag功能 自动发布到某篇文章到Hexo 新建文章本来计划通过Alfred进行新建文章功能，查询了一下MWeb数据库由于不知道文章ID的生成规则（只知道应该是用时间戳来标识文章ID的，但位数不对，多了4位），所以不敢轻易的往里面插入数据。如果以后有这样的需求，再增加这个功能进去吧。 查询文章具体实现参考了Github-MWeb-Alfred主要也是通过查询数据库来实现的。具体可看原作者的Github-MWeb-Alfred 增加Tag功能通过查看MWeb数据库可以得知，要得到一个文章的所有tag，则需要连表查询，具体的sqlite 语句如下1SELECT b.name FROM tag_article a,tag b WHERE ( a.aid='$&#123;fileid&#125;' AND a.rid = b.id); 完整bash代码:searchtag.sh 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/bin/bash# DESCRIPTION: 将查询出来的md，进行二次查询，把tag汇总，输出tag1,tag2,...# 环境变量和目录检查if [ -z "$&#123;MDOC_HOME&#125;" ];then echo "&#123; \"items\":[" echo "&#123;" echo "\"type\": \"error\"," echo "\"title\": \"请设置环境变量MDOC_HOME\"" echo "&#125;" echo "]&#125;" exit 1fiMDOC_HOME=$(eval "echo $&#123;MDOC_HOME&#125;")if [ ! -d "$&#123;MDOC_HOME&#125;/docs" ];then echo "&#123; \"items\":[" echo "&#123;" echo "\"type\": \"error\"," echo "\"title\": \"\\\"$&#123;MDOC_HOME&#125;/docs\\\" 目录不存在\"" echo "&#125;" echo "]&#125;" exit 1ficd "$&#123;MDOC_HOME&#125;/docs" params="$&#123;1&#125;" # md文章idIFS=';' read -r -a array &lt;&lt;&lt; "$&#123;1&#125;"fileid="$&#123;array[0]&#125;"fileid="$&#123;fileid/.md/&#125;"title="$&#123;array[1]&#125;"taglist=""# 输出文档列表的函数output_result()&#123; if [ "$&#123;files&#125;" = "" ];then echo "$&#123;MDOC_HOME&#125;/docs/$&#123;fileid&#125;.md;$&#123;title&#125;;" exit fi for i in $&#123;files&#125; do if [ "$&#123;taglist&#125;" = "" ];then taglist="$&#123;i&#125;" else taglist="$&#123;taglist&#125;","$&#123;i&#125;" fi done echo "$&#123;MDOC_HOME&#125;/docs/$&#123;fileid&#125;.md;$&#123;title&#125;;$&#123;taglist&#125;" exit&#125;sql="SELECT b.name FROM tag_article a,tag b WHERE ( a.aid='$&#123;fileid&#125;' AND a.rid = b.id);"final_expr="sqlite3 \"$&#123;MDOC_HOME&#125;/mainlib.db\" \"$&#123;sql&#125;\""final_expr="$&#123;final_expr&#125;"# echo "$final_expr"files=`eval "$&#123;final_expr&#125;"`output_result 自动发布某篇文章到Hexo搜索文章-&gt;查询文章所有的tag-&gt;增加Hexo能识别的内容-&gt;发布我在原作者的查询里面修改了一下，因为查询出来的结果是/Users/rinfon/Desktop/work/workstyle/blogfile/docs/15471063755188.md这种路径的，而我需要一个文章的id和文章的title即可15471063755188;title，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#!/bin/bash# NOTE: 本脚本要求所有参数用'或"合成一个参数，如 -t TODO 要输入为 '-t TODO' 或 "-t TODO"# alfred 会将所有输入作为一个参数，包括末尾的空格# 环境变量和目录检查if [ -z "$&#123;MDOC_HOME&#125;" ];then echo "&#123; \"items\":[" echo "&#123;" echo "\"type\": \"error\"," echo "\"title\": \"请设置环境变量MDOC_HOME\"" echo "&#125;" echo "]&#125;" exit 1fiMDOC_HOME=$(eval "echo $&#123;MDOC_HOME&#125;")if [ ! -d "$&#123;MDOC_HOME&#125;/docs" ];then echo "&#123; \"items\":[" echo "&#123;" echo "\"type\": \"error\"," echo "\"title\": \"\\\"$&#123;MDOC_HOME&#125;/docs\\\" 目录不存在\"" echo "&#125;" echo "]&#125;" exit 1ficd "$&#123;MDOC_HOME&#125;/docs"declare -a tag_arr # 标签数组declare -a header_arr # 标题数组declare -a category_arr # 分类数组declare -a keyword_arr # 关键字数组next_input=0 # 下一步输入参数归类，0:keyword, 1: tag, 2: header, 3: categorylast_input=0 # 最后一次输入的参数归类；与next_input 相同end_option=1 # 是否终止了除 keyword 以外类型的参数输入: 单最后一个字符为空格表示输出完成了end_char="" # 最后一个参数最后输入的字符# 收集参数的函数：# 1.收集tag,header,keyword参数，分别放到 tag_arr,header_arr,keyword_arr中# 2.判断用户一下个要输入的参数(next_input)get_params()&#123; while [ $# -gt 0 ]; do case "$1" in -t)# echo "$1" next_input=1 last_input=$&#123;next_input&#125; shift;; -h)# echo "$1" next_input=2 last_input=$&#123;next_input&#125; shift;;# -c|--category)# echo "$1"# next_input=3# last_input=$&#123;next_input&#125;# shift;; *)# echo "$1" str=$&#123;1//，/,&#125; # 中文逗号改成英文逗号 n=$&#123;#str&#125; end_char=$&#123;str:$((n-1))&#125; # 记录最后一个字符 # 按照 next_input 指示，将参数放到对应的数组中。 case "$&#123;next_input&#125;" in 1) IFS=","; for i in $&#123;str&#125;;do tag_arr+=("$i"); done;unset IFS ;; 2) IFS=","; for i in $&#123;str&#125;;do header_arr+=("$i"); done;unset IFS ;; 3) IFS=","; for i in $&#123;str&#125;;do category_arr+=("$i"); done;unset IFS ;; *) keyword_arr+=("$str") ;; esac last_input=$&#123;next_input&#125; # 保存最后一次输入的参数类型 next_input=0; shift;; esac done&#125;get_params $* # 调用收集参数的函数#echo tag_arr=$&#123;tag_arr[@]&#125;#echo header_arr=$&#123;header_arr[@]&#125;#echo category_arr=$&#123;category_arr[@]&#125;#echo keyword_arr=$&#123;keyword_arr[@]&#125;#echo next_input=$&#123;next_input&#125;#echo last_input=$&#123;last_input&#125;# 输出tag列表的函数output_tags()&#123; if [ "$&#123;filtered_tags&#125;" = "" ];then echo "&#123;\"items\":[" echo "&#123;" echo "\"title\": \"没有相关tag\"," echo "&#125;" echo "]&#125;" exit fi local separator="" echo "&#123;\"items\":[" for i in $&#123;filtered_tags&#125; do printf '%s' $&#123;separator&#125; separator="," echo "&#123;" echo "\"title\": \"tag: $&#123;i&#125;\"," echo "\"autocomplete\": \"$&#123;1&#125;$&#123;i&#125;,\"," echo "\"valid\":\"no\"" echo "&#125;" done echo "]&#125;" exit&#125;# 输出文档列表的函数output_files()&#123; if [ "$&#123;files&#125;" = "" ];then echo "&#123;\"items\":[" echo "&#123;" echo "\"title\": \"没有找到符合条件的文档\"," echo "&#125;" echo "]&#125;" exit fi local separator="" echo "&#123;\"items\":[" for i in $&#123;files&#125; do printf '%s' $&#123;separator&#125; separator="," h="$(head -1 "$&#123;i&#125;"| sed 's/\\/\\\\/g;s/"/\\"/g;s/[[:space:]]*$//g')" echo "&#123;" echo "\"type\": \"file\"," echo "\"title\": \"$&#123;h&#125;\"," echo "\"arg\": \"$i;$h\"" echo "&#125;" done echo "]&#125;"&#125;# 最后一个字符不是空格，且最后一次输入归类不是0，这表示该类型参数没有输入完成 --&gt; 可以输出该类型选项if [ "$*" = "$&#123;*% &#125;" -a $&#123;last_input&#125; -gt 0 ];then end_option=0# 下一个参数类型=最后一次输入类型，且类型不是0，表示该类型参数没有输入完成 --&gt; 可以输出该类型选项elif [ $&#123;next_input&#125; -gt 0 -a $&#123;last_input&#125; = $&#123;next_input&#125; ];then end_option=0else end_option=1fi#echo "end_option=$&#123;end_option&#125;"## 如果当前输入为 tag，且没有结束输入，输出tag列表: 排除已经输入的tag，以当前输入为前缀的tagif [ $&#123;last_input&#125; -eq 1 -a $&#123;end_option&#125; -eq 0 ]; then autocomplete='' n=$&#123;#tag_arr[@]&#125; if [ $&#123;n&#125; -eq 0 ];then # 还没有输入任何值 autocomplete="$1 " sql="select name from tag"; elif [ "$&#123;end_char&#125;" = "," ];then # 已输入若干个值，且最后一个值已确定 autocomplete="$1" sql="select name from tag where 1=1"; for i in $&#123;tag_arr[@]&#125; do sql="$&#123;sql&#125; and name not like '$&#123;i&#125;'" done else # 已输入若干个值，且最后一个值还没有输入完成 n=$((n-1)) autocomplete="$&#123;1%$&#123;tag_arr[$&#123;n&#125;]&#125;&#125;" sql="select name from tag where name like '$&#123;tag_arr[@]:$n&#125;%'"; for i in $&#123;tag_arr[@]:0:$&#123;n&#125;&#125; do sql="$&#123;sql&#125; and name not like '$&#123;i&#125;'" done fi# echo $&#123;sql&#125; final_expr="sqlite3 \"$&#123;MDOC_HOME&#125;/mainlib.db\" \"$&#123;sql&#125;\"" filtered_tags=`eval "$&#123;final_expr&#125;"` output_tags "$&#123;autocomplete&#125;" exitfi## 如果有输入-t参数，过滤文档tag## 查询文档SQL:##SELECT a.aid FROM tag_article a,article b##WHERE a.aid = b.uuid AND## a.rid IN (SELECT id from tag b WHERE b.name LIKE 'TODO' or b.name LIKE 'DONE' )##GROUP BY a.aid HAVING count(1) &gt;=2##ORDER BY b.dateModif DESC;if [ $&#123;#tag_arr[@]&#125; -gt 0 ];then sql='select id from tag where ' or_str="" for i in $&#123;tag_arr[@]&#125; do sql="$&#123;sql&#125; $&#123;or_str&#125; name like '$&#123;i&#125;'" or_str=or done sql="SELECT a.aid||'.md' FROM tag_article a,article b \ WHERE a.aid=b.uuid AND a.rid IN ($&#123;sql&#125;) \ GROUP BY a.aid HAVING count(1)&gt;=$&#123;#tag_arr[@]&#125; \ ORDER BY b.dateModif desc";# echo $&#123;sql&#125; final_expr="sqlite3 \"$&#123;MDOC_HOME&#125;/mainlib.db\" \"$&#123;sql&#125;\""else final_expr="ls -t *.md"fi# 如果有输入-h参数，过滤文档标题# 思路: grep -n 会输出行号，找到符合所有关键字的行，筛选行号=1的文档就可以了if [ $&#123;#header_arr[@]&#125; -gt 0 ];then final_expr="$&#123;final_expr&#125; | xargs grep -inHe '$&#123;header_arr[0]&#125;'" for i in $&#123;header_arr[@]:1&#125; do final_expr="$&#123;final_expr&#125; | grep -ie '$&#123;i&#125;'" done final_expr="$&#123;final_expr&#125; | egrep '^.+\.md\:1\:' | awk -F':' '&#123;print \$1&#125;'"fi# 如果有输入关键字，则用关键字筛选文档，并且按照文档标题匹配度排序if [ $&#123;#keyword_arr[@]&#125; -gt 0 ];then for i in $&#123;keyword_arr[@]&#125; do final_expr="$&#123;final_expr&#125;| xargs grep -ile '$&#123;i&#125;' | awk -F':' '&#123;print \$1&#125;' | uniq " done # 排序表达式: 统计第一行匹配关键字个数，将匹配个数大的放在前面 # 第一步: 输入"文件名",输出"文件名 匹配个数" # 第二步: 按照 "匹配个数" 倒序排序 # 第三步: 去掉 "匹配个数" 字段，只保留"文件名" # 由于ls -lt 是按照编辑时间倒序排序的，所以最终排序等级：标题匹配个数倒序-&gt;最后编辑倒序 egrep_expr="$(echo "$&#123;keyword_arr[@]&#125;" | sed "s/[[:blank:]]/|/g")" sort_expr="awk '&#123;system(\"egrep -ioe \\\"$&#123;egrep_expr&#125;\\\" &lt;&lt;&lt; \`head -1 \"\$1 \"\`|wc -l | xargs echo \"\$1)&#125;' | sort -rk 2 | awk '&#123;print \$1&#125;'" final_expr="$&#123;final_expr&#125; | $&#123;sort_expr&#125; "fifinal_expr="$&#123;final_expr&#125; | head -20 " # 限制最多输出20条记录# echo "$final_expr"files=`eval "$&#123;final_expr&#125;"`output_files 为了让Hexo识别，增加了一下脚本1234567891011121314151617181920212223242526272829303132333435363738394041if [ ! -n "$&#123;HEXO_POST&#125;" ] ;then exit 1fiIFS=';' read -r -a array &lt;&lt;&lt; "&#123;query&#125;"path=$&#123;array[0]&#125;title=$&#123;array[1]&#125;title="$&#123;title/\# /&#125;"taglist=$&#123;array[2]&#125;cp "$path" "$&#123;HEXO_POST&#125;/$&#123;title&#125;.md"cd "$&#123;HEXO_POST&#125;"#删除titlesed -i '' 1d ./"$&#123;title&#125;.md"sed -i '' '1i\'$'\n---\n' ./"$&#123;title&#125;.md"sed -i '' "1 a\ title: $title" ./"$&#123;title&#125;.md"sed -i '' "2 a\ tag: [$&#123;taglist&#125;]" ./"$&#123;title&#125;.md"sed -i '' '3 a\'$'\n---\n' ./"$&#123;title&#125;.md"linecount=$(cat ./"$&#123;title&#125;.md" | wc -l )if [ $linecount -gt 11 ];then sed -i '' "12 a\ &lt;!--more--&gt; " ./"$&#123;title&#125;.md"fiPATH=$&#123;HEXO_CMD_PATH&#125;PATH=$&#123;PATH&#125;:$&#123;GIT_PATH&#125;hexo cleanhexo ghexo d 遇到的问题 alfred 执行git、hexo命令找不到问题需要把git的命令路径和hexo路径填写在alfred的环境变量里面。不然执行会git和hexo的操作会失败。]]></content>
      <tags>
        <tag>git</tag>
        <tag>MWeb</tag>
        <tag>Hexo</tag>
        <tag>Alfred</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 项目架构之 MVP]]></title>
    <url>%2F2019%2F01%2F15%2FAndroid%20%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E4%B9%8B%20MVP%2F</url>
    <content type="text"><![CDATA[需求本文不是学术文字讨论（复制粘贴）文，所以不会详细解释什么叫 MVP，MVC，Dagger，Clean 等等。主要以实际项目为基础，简单的实现登录功能。 当代码量越来越大，需要对已有的代码进行整理以及重构，实现解耦. 无论任何的架构模式以及设计模式都是为了代码解耦 研究方向MVP 模式： Model:数据层，主要负责网络数据请求与获取，数据库的处理等等数据相关的逻辑处理 View:视图层，显示数据，例如 Activity,Fragment,View 等等 UI 载体 Presenter:代理层, View 逻辑处理的集合，并且将 Model 获取的数据返回给 View 层 MVP 类型 MVP 简单版 MVP-Clean主要参考实现 Clean Architecture. MVP-DaggerDragger2 的 MVP 实现 MVP-RxJavaRxJava 的 MVP 实现MVP 的简单实现逻辑图 ViewUI 的展示 BasePresenterImpl封装了 View 的处理流程，数据回调等等，例如进行网络请求的时候，loading 的显示与隐藏。 LoginPresenter登录逻辑处理的地方 BaseRespository封装了异常处理，例如网络请求回调的时候，页面消失了，这时候再进行 ui 处理的话就会奔溃。为了不每个页面都加上判空处理，所以就封装了一层。如不需要可以去掉这一层 LoginRespository登录真正执行的地方 关键代码 MainActivity.java 1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends Activity implements IBaseView&lt;String&gt; &#123; LoginPresenter loginPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); loginPresenter = new LoginPresenter(this); loginPresenter.toLogin("111", "111"); &#125; @Override protected void onDestroy() &#123; loginPresenter.unBind(); super.onDestroy(); &#125; @Override public void onSuccess(String Result) &#123; Log.i("MainActivity", Result); &#125; @Override public void onFailed(ErrorCode errorCode) &#123; Log.i("MainActivity", errorCode.getMessage()); String msg = null; msg.toLowerCase(); &#125; @Override public void showProgress() &#123; Log.i("MainActivity", "loading"); &#125; @Override public void hideProgress() &#123; Log.i("MainActivity", "hide loading"); &#125; &#125; LoginPresenter.java 123456789101112131415public class LoginPresenter extends BasePresenterImpl &#123; IBaseRepository baseRepository; public LoginPresenter(IBaseView mView) &#123; super(mView); &#125; public void toLogin(String uid, String password) &#123; mView.showProgress(); baseRepository = LoginRepository.Builder(baseCallback) .setUid(uid).setPassword(password); baseRepository.Action(); &#125; &#125; LoginRepository.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class LoginRepository extends BaseRepository implements IBaseRepository &#123; private String uid; private String password; public static LoginRepository Builder(BaseInteractor.Callback callback) &#123; return new LoginRepository(callback); &#125; public String getUid() &#123; return uid; &#125; public LoginRepository setUid(String uid) &#123; this.uid = uid; return this; &#125; public String getPassword() &#123; return password; &#125; public LoginRepository setPassword(String password) &#123; this.password = password; return this; &#125; public LoginRepository(BaseInteractor.Callback callback) &#123; super(callback); &#125; @Override public void Action() &#123; // TODO // 网络请求 // onRequsetSuccess("login success"); onRequestFailed(new ErrorCode().setStatus(0).setMessage("login fail")); &#125; @Override public void Cancel() &#123; // TODO // 取消网络请求 // 回调上一次进行异常处理 onCancel(); &#125; &#125; 完整代码已经上传到github上去了 -&gt; https://github.com/rinfon/mvp.git MVP-Clean逻辑图 Clean 架构图 时序图就像这篇文章Android 官方架构项目之 MVP + Clean 所说，clean 架构比简单版的 MVP 就是多了一层 Domain 层，减轻 Presenter 的负担。 关键代码 在研究官方的Demo中，有些地方还是值得斟酌的 View 层不通用，例如有些 loading，onSuccess，onError 等通用函数应该抽象到 BaseView 里面去，减少代码量 所有的 Task 都在一开始就在界面初始化好了，如果有些功能我没有用到，那么就浪费资源了，应该改成需要用到的时候再初始化 在 presenter 初始化的时候，View 层传的参数太多了。例如 View 层所有的 task 都要初始化好传进去。个人认为这是不科学的。但后来想官方这样写的原因是为了区分 View 与 Presenter 的职责（看来我还是太年轻了），View 作为数据的提供者，Presenter 作为数据的接受者。所以才不在 Presenter 层新建数据。既然如此，那只需要 Builder 模式就可以解决参数过多的问题了。 Presenter 层 callback 重复代码过多，例如 123456789101112131415mUseCaseHandler.execute(loginTask, new LoginTask.LoginRequestValues(uid, password), new UseCase.UseCaseCallback&lt;BaseResponseValues&gt;() &#123; @Override public void onSuccess(BaseResponseValues response) &#123; mView.closeLoading(); mView.onSuccess(response); &#125; @Override public void onError() &#123; mView.closeLoading(); mView.onFail(); &#125; &#125;); 每次 excute 都需要提供一个 callback，而每个 callback 仅仅 response 的类型不一样而已。流程还是一样的。所以重复代码还是很多。 原本想在 UserCaseHandler 里面增加 View 的持有，从而在 UserCaseHandler 进行 CallBack 的时候把 closeloading 和 onSucces，onFail 都写好，这样就可以解决问题了。 这样的设计方案有个弊端，View 层入侵了 UserCaseHandler，耦合度又增加了。所以看实际需求来权衡吧 来来来，上代码 MvpCleanActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142public class MvpCleanActivity extends Activity implements LoginContract.View&lt;BaseResponseValues&gt; &#123; CleanLoginPresenter loginPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); loginPresenter = new CleanLoginPresenter(this, UseCaseHandler.getInstance(), new LoginTask()); loginPresenter.login("111", "111"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); &#125; @Override public void showLoading() &#123; Log.i("MvpCleanActivity", "showloading"); &#125; @Override public void closeLoading() &#123; Log.i("MvpCleanActivity", "closeloading"); &#125; @Override public void onSuccess(BaseResponseValues r) &#123; Log.i("MvpCleanActivity", r.getResult().getMessage()); // will crash String msg = null; msg.toLowerCase(); &#125; @Override public void onFail() &#123; Log.i("MvpCleanActivity", "login fail"); &#125; CleanLoginPresenter.java 12345678910111213141516171819202122232425262728293031323334public class CleanLoginPresenter implements LoginContract.Presenter &#123; private final LoginContract.View mView; private final UseCaseHandler mUseCaseHandler; private final LoginTask loginTask; public CleanLoginPresenter(LoginContract.View mView, UseCaseHandler mUseCaseHandler, LoginTask loginTask) &#123; // TODO 参数过多，使用 builder 模式 this.mView = mView; this.mUseCaseHandler = mUseCaseHandler; this.loginTask = loginTask; &#125; @Override public void login(String uid, String password) &#123; mView.showLoading(); mUseCaseHandler.execute(loginTask, new LoginTask.LoginRequestValues(uid, password), new UseCase.UseCaseCallback&lt;BaseResponseValues&gt;() &#123; @Override public void onSuccess(BaseResponseValues response) &#123; mView.closeLoading(); mView.onSuccess(response); &#125; @Override public void onError() &#123; mView.closeLoading(); mView.onFail(); &#125; &#125;); &#125; LoginTask.java 123456789101112131415161718192021222324252627public class LoginTask extends UseCase&lt;LoginTask.LoginRequestValues, BaseResponseValues&gt; &#123; @Override protected void executeUseCase(LoginRequestValues requestValues) &#123; // TODO 网络请求 // 回调 getUseCaseCallback().onSuccess(new BaseResponseValues( ResponseEntry .Builder() .setStatus(1) .setMessage("Login success"))); &#125; public static final class LoginRequestValues extends BaseRequsetValues &#123; public LoginRequestValues(@NonNull String uid, @NonNull String password) &#123; super(new HashMap&lt;String, String&gt;()); uid = checkNotNull(uid, "task cannot be null!"); password = checkNotNull(password, "task cannot be null!"); getParmas().put("uid", uid); getParmas().put("password", password); &#125; &#125; &#125; LoginTask 里面跟官方还是不一样的，因为实际需求中，请求的参数和返回的结果结构大多数都是一样的，所以 RequestValues 和 ResponseValues 还是可以封装成公用的。 LoginContract.java 123456789101112131415public class LoginContract &#123; public interface View&lt;T&gt; &#123; void showLoading(); void closeLoading(); void onSuccess(T Result); void onFail(); &#125; public interface Presenter &#123; void login(String uid, String password); &#125; &#125; 就像本文所说，View 层可以再封装成 BaseView，把重复的的代码放进去 UserCase相关的就不放出来了，官方已经封装好了，实际上就是封装了一个线程池，用于异步处理 Task，所以直接使用即可。完整代码已经上传到 github上去了 -&gt; https://github.com/rinfon/mvp.git MVP-Dagger 未完待续 MVP-RxJavaRxJava ，之前我一直很抗拒，因为上手感觉很难，另一部分可能自己心燥，静不下来好好研究。但最近看 MVP-clean 的时候有用到，所以也就铁下心来研究了一下。 本来想写篇文章来分享一下的，但后来看到大神们都已经解释的很清楚，连我都能看懂的，我相信你们都能看懂的。 附上链接 ，小水管 RxJava 通过作者的小水管，我相信你们也会喜欢上 RxJava 的。 回到整体 MVP-RxJava，我看了 google 的 demo 之后，发现其实没什么特别的神的地方（应该是没什么出彩的地方），也就是简单版的 MVP 加上 RxJava 而已，所以 demo 就不放出来了。放出关键代码吧 LoginPresenter.Java 123456789101112131415161718192021222324mCompositeDisposable.add(Observable.create(new ObservableOnSubscribe&lt;User&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;User&gt; e) throws Exception &#123; User user = new User(); user.uid = uid; user.password = password; e.onNext(user); e.onComplete(); &#125; &#125;).subscribeOn(mSchedulerProvider.io()) .observeOn(mSchedulerProvider.ui()) .subscribe(new Consumer&lt;User&gt;() &#123; @Override public void accept(User user) throws Exception &#123; mView.closeLoading(); mView.onSuccess(user); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; mView.closeLoading(); mView.onFail(); &#125; &#125;)); 总结 任何架构设计都是为了解耦，而解耦随之带来的就是代码的增加以及重复 设计的过程中，要注意各层的职责，尽量可以避免入侵 在我的 Demo 中，为了处理回调导致的奔溃，我对回调进行了 try catch，这没有问题，但要对详细的异常进行区分，不能所有的异常都吃掉，这是一种不负责的写法（小孩子不要模范啦）有时候，就应该让它 Crash，才知道问题所在。如果非要吃掉所有的异常，也要封装成一个 ErrorCode，对错误信息进行收集。知乎链接，里面有大牛解释的很清楚了。]]></content>
      <tags>
        <tag>MVP</tag>
        <tag>MVVM</tag>
        <tag>Android架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android studio Jar 包制作以及混淆]]></title>
    <url>%2F2019%2F01%2F12%2F2019-01-12-android%20studio%20Jar%20%E5%8C%85%E5%88%B6%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%B7%B7%E6%B7%86%2F</url>
    <content type="text"><![CDATA[需求 项目越来越大，需要对核心代码进行封装加密管理 Jar 包制作 优点：简单，方便 缺点：不能把资源文件都打进去 Jar 包里面，例如图片，布局文件等等 aar 制作 优点：跟 Jar 一样，可以把资源文件都打包进去，AS可以直接引用，管理方便 缺点：- so 制作 优点：增加反编译难度，核定代码可以放进去 缺点：需要 C/C++基础，并不是所有都适合放到 so 里面去。 实现制作 新建一个 module，选择 Android Library Finish 把你需要封装的代码写在 module 里面去 打包 在 module 里面的 build.gradle 文件加入一下 Task 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748task buildJar(type: Jar, dependsOn: ['compileReleaseJavaWithJavac']) &#123; // task buildJar(type: Jar, dependsOn: ['build'])// 导出的 jar 文件的名称 archiveName = "testJar-debug.jar" //需打包的资源所在的路径集 from('build/intermediates/classes/release') destinationDir = file('../libs') // //导出的 jar 文件的存放目录（未指定则默认存放在 build/libs 下） destinationDir = file('D:/libs') exclude "**/BuildConfig.class" //去掉不要的类 exclude('**/R.class') exclude('**/R\$*.class') include "**/*.*" //需要打包的类 如 // include('com/reginer/mytest/*.class')&#125;task proguardJar(dependsOn: ['buildJar'], type: ProGuardTask) &#123; println('proguard '+project.name+' jar') //Android 默认的 proguard 文件 configuration android.getDefaultProguardFile('proguard-android.txt') //加载各模块 proguard 配置文件 configuration 'proguard-rules.pro' String inJar = buildJar.archivePath.getAbsolutePath() injars inJar outjars inJar.substring(0, inJar.lastIndexOf('-')) + "-release.jar" //设置不删除未引用的资源(类，方法等) dontshrink //运行时 jar 包不混淆 Plugin plugin = getPlugins().hasPlugin(AppPlugin) ? getPlugins().findPlugin(AppPlugin) : getPlugins().findPlugin(LibraryPlugin) if (plugin != null) &#123; List&lt;String&gt; runtimeJarList if (plugin.getMetaClass().getMetaMethod("getRuntimeJarList")) &#123; runtimeJarList = plugin.getRuntimeJarList() &#125; else if (android.getMetaClass().getMetaMethod("getBootClasspath")) &#123; runtimeJarList = android.getBootClasspath() &#125; else &#123; runtimeJarList = plugin.getBootClasspath() &#125; for (String runtimeJar : runtimeJarList) &#123; libraryjars(runtimeJar) &#125; &#125;&#125; 打开 Gradle 任务，执行 buildJar 然后再执行 proguardJar 任务进行混淆 最后你会发现在项目中出现 test-relase.jar 注意buildJar里面archiveName名字必须有-，不然会执行错误的。原因在与在混淆的时候，需要把包名改成 relase.不喜欢的可以自行修改逻辑代码 注意buildJar里面archiveName名字必须有-，不然会执行错误的。原因在与在混淆的时候，需要把包名改成 relase.不喜欢的可以自行修改逻辑代码 注意buildJar里面archiveName名字必须有-，不然会执行错误的。原因在与在混淆的时候，需要把包名改成 relase.不喜欢的可以自行修改逻辑代码]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 found an invalid color]]></title>
    <url>%2F2019%2F01%2F11%2F2019-01-11-%E8%A7%A3%E5%86%B3%20found%20an%20invalid%20color%2F</url>
    <content type="text"><![CDATA[问题在导入 eclipse 项目的时候，有时候会出现 found an invalid color 这个问题，原因在于 AS 对.9 图片的检查 解决方法 图片是.9.png 格式的，但是没有画黑色边框线，需要画上边框线，保存就可以了。或者直接把.9 格式去掉即可]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 的简单介绍]]></title>
    <url>%2F2019%2F01%2F11%2F2019-01-11-git%20%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[git 的简单介绍是什么? Git 是目前世界上最先进的分布式版本控制系统。 为什么 适合分布式开发 速度快，灵活 优秀的解决冲突能力 版本管理 工作流程 克隆项目 修改项目 提交更改 拉取远端最新的更改（如果别人在你修改期间有更改推送过，则需要拉取） 如本地修改跟远端修改有冲突，则解决冲突 重新提交 推送远端 对应流程图如下： 常用命令 git init用于初始化项目 git clone用于克隆项目 git add添加修改文件。其中 git add .代表添加所有修改过的问题件，git add 文件路径,代表添加特定的文件。 git commit提交更改日志，例如 git commit -m “增加功能” git fetch检查远端是否有更改 git pull拉取远端的最新的代码，例如 git pull –rebase.rebase 和 merge 的区别在于：merge 操作会生成一个新的节点，之前的提交分开显示。而 rebase 操作不会生成新的节点，是将两个分支融合成一个线性的提交。所以我们通常 git pull 都会加上 rebase 的参数 git push推送本地更改到服务器,例如 git push orgin master git branch查看当前分支,而如果加上-r 参数，代表查看远程分支 git branch -r git checkout切换分支 例如，git checkout -b develop，切换到 develop 分支，如果本地已经有 develop 分支，则 git checkout develop git tag为节点打日志，例如，我们要为 1b2e1d63ff 打上 1.0 的标签:git tag 1.0 1b2e1d63ff git reset丢弃所有的本地所有的更改，git reset HEAD –hard,同时也可以用此命令回到之前的节点，如果我要返回到上一个节点（注意，此返回指的是你本地返回，而不是远端返回），git reset HEAD^ –hard git status查看本地缓存修改记录 常用技巧现在有 a、b、c、d、e，5 个提交点，我需要切换回滚到 c 节点，丢弃的 d,e 节点git reset HEAD^^ --hard（或者 git reset c 点的 sha 码 --hard） git push origin HEAD --force 把别的分支某个提交点提交到当前分支 例如 develop 上有提交点 a(sha 码为 1b2e1d63ff),需要把 a 也提交到 master 上去. git checkout master git cherry-pick -x 1b2e1d63ff,-x 代表着保留原始作者信息 如果途中产生冲突，则按照标准的解决冲突方法去解决。然后重新 commit 即可 查找某个文件的某行修改记录 新接手了一个项目，里面某一行代码不知道为什么原作者这样写，需要查看对应的提交点记录才能知道为啥当初这样写 例如要查看 a.java 文件的修改记录 git blame **/a.java(注意文件路径),得到如下结果 12345678910^5cdd7bd (Rinfon 2018-04-02 13:14:34 +0800 68) LocalTextView apStepBack;^5cdd7bd (Rinfon 2018-04-02 13:14:34 +0800 69) @BindView(R.id.ap_step_next)^5cdd7bd (Rinfon 2018-04-02 13:14:34 +0800 70) LocalTextView apStepNext;20997902 (Rinfon 2018-06-25 12:03:13 +0800 71) @BindView(R.id.ap_step_three_icon)20997902 (Rinfon 2018-06-25 12:03:13 +0800 72) ImageView apStepThreeIcon;20997902 (Rinfon 2018-06-25 12:03:13 +0800 73) @BindView(R.id.wifi_remember)20997902 (Rinfon 2018-06-25 12:03:13 +0800 74) CheckBox wifiRemember;20997902 (Rinfon 2018-06-25 12:03:13 +0800 75) @BindView(R.id.ap_step_btn_layout)20997902 (Rinfon 2018-06-25 12:03:13 +0800 76) LinearLayout apStepBtnLayout;^5cdd7bd (Rinfon 2018-04-02 13:14:34 +0800 77) private Unbinder unbinder; 这时候已经得到了 sha 码，就可以通过 git show 20997902,可以得到修改的信息。 分支管理主要分支 master 分支。仅且只有一个主分支，用于提供正式版本 develop 分支，开发分支，用于日常开发，如果一个版本开发完整，测试通过，则合并到 develop 里面去。合并的时候需要加上 –no-ff，快进式合并，保证版本的演进清晰。临时分支 feature 分支，当需要做一个新功能时，需要基于 develop 开一个 feature 分支，即使 feature 不完成，也不会影响 develop 的进度. hotfix 分支，用于修改 bug 的分支，基于 master 分出来的。修改结束后，合并到 master 和 develop 上去 但这只是一个基础想法，并不是适用于所有的项目的，而我们需要做的，就是对此策略加以修改，变成适合自己的分支管理。]]></content>
  </entry>
</search>
