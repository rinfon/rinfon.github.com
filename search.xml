<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 项目架构之 MVP]]></title>
    <url>%2F2019%2F01%2F15%2FAndroid%20%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E4%B9%8B%20MVP%2F</url>
    <content type="text"><![CDATA[需求本文不是学术文字讨论（复制粘贴）文，所以不会详细解释什么叫 MVP，MVC，Dagger，Clean 等等。主要以实际项目为基础，简单的实现登录功能。 当代码量越来越大，需要对已有的代码进行整理以及重构，实现解耦. 无论任何的架构模式以及设计模式都是为了代码解耦 研究方向MVP 模式： Model:数据层，主要负责网络数据请求与获取，数据库的处理等等数据相关的逻辑处理 View:视图层，显示数据，例如 Activity,Fragment,View 等等 UI 载体 Presenter:代理层, View 逻辑处理的集合，并且将 Model 获取的数据返回给 View 层 MVP 类型 MVP 简单版 MVP-Clean主要参考实现 Clean Architecture. MVP-DaggerDragger2 的 MVP 实现 MVP-RxJavaRxJava 的 MVP 实现MVP 的简单实现逻辑图 ViewUI 的展示 BasePresenterImpl封装了 View 的处理流程，数据回调等等，例如进行网络请求的时候，loading 的显示与隐藏。 LoginPresenter登录逻辑处理的地方 BaseRespository封装了异常处理，例如网络请求回调的时候，页面消失了，这时候再进行 ui 处理的话就会奔溃。为了不每个页面都加上判空处理，所以就封装了一层。如不需要可以去掉这一层 LoginRespository登录真正执行的地方 关键代码 MainActivity.java 1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends Activity implements IBaseView&lt;String&gt; &#123; LoginPresenter loginPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); loginPresenter = new LoginPresenter(this); loginPresenter.toLogin("111", "111"); &#125; @Override protected void onDestroy() &#123; loginPresenter.unBind(); super.onDestroy(); &#125; @Override public void onSuccess(String Result) &#123; Log.i("MainActivity", Result); &#125; @Override public void onFailed(ErrorCode errorCode) &#123; Log.i("MainActivity", errorCode.getMessage()); String msg = null; msg.toLowerCase(); &#125; @Override public void showProgress() &#123; Log.i("MainActivity", "loading"); &#125; @Override public void hideProgress() &#123; Log.i("MainActivity", "hide loading"); &#125; &#125; LoginPresenter.java 123456789101112131415public class LoginPresenter extends BasePresenterImpl &#123; IBaseRepository baseRepository; public LoginPresenter(IBaseView mView) &#123; super(mView); &#125; public void toLogin(String uid, String password) &#123; mView.showProgress(); baseRepository = LoginRepository.Builder(baseCallback) .setUid(uid).setPassword(password); baseRepository.Action(); &#125; &#125; LoginRepository.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class LoginRepository extends BaseRepository implements IBaseRepository &#123; private String uid; private String password; public static LoginRepository Builder(BaseInteractor.Callback callback) &#123; return new LoginRepository(callback); &#125; public String getUid() &#123; return uid; &#125; public LoginRepository setUid(String uid) &#123; this.uid = uid; return this; &#125; public String getPassword() &#123; return password; &#125; public LoginRepository setPassword(String password) &#123; this.password = password; return this; &#125; public LoginRepository(BaseInteractor.Callback callback) &#123; super(callback); &#125; @Override public void Action() &#123; // TODO // 网络请求 // onRequsetSuccess("login success"); onRequestFailed(new ErrorCode().setStatus(0).setMessage("login fail")); &#125; @Override public void Cancel() &#123; // TODO // 取消网络请求 // 回调上一次进行异常处理 onCancel(); &#125; &#125; 完整代码已经上传到github上去了 -&gt; https://github.com/rinfon/mvp.git MVP-Clean逻辑图 Clean 架构图 时序图就像这篇文章Android 官方架构项目之 MVP + Clean 所说，clean 架构比简单版的 MVP 就是多了一层 Domain 层，减轻 Presenter 的负担。 关键代码 在研究官方的Demo中，有些地方还是值得斟酌的 View 层不通用，例如有些 loading，onSuccess，onError 等通用函数应该抽象到 BaseView 里面去，减少代码量 所有的 Task 都在一开始就在界面初始化好了，如果有些功能我没有用到，那么就浪费资源了，应该改成需要用到的时候再初始化 在 presenter 初始化的时候，View 层传的参数太多了。例如 View 层所有的 task 都要初始化好传进去。个人认为这是不科学的。但后来想官方这样写的原因是为了区分 View 与 Presenter 的职责（看来我还是太年轻了），View 作为数据的提供者，Presenter 作为数据的接受者。所以才不在 Presenter 层新建数据。既然如此，那只需要 Builder 模式就可以解决参数过多的问题了。 Presenter 层 callback 重复代码过多，例如 123456789101112131415mUseCaseHandler.execute(loginTask, new LoginTask.LoginRequestValues(uid, password), new UseCase.UseCaseCallback&lt;BaseResponseValues&gt;() &#123; @Override public void onSuccess(BaseResponseValues response) &#123; mView.closeLoading(); mView.onSuccess(response); &#125; @Override public void onError() &#123; mView.closeLoading(); mView.onFail(); &#125; &#125;); 每次 excute 都需要提供一个 callback，而每个 callback 仅仅 response 的类型不一样而已。流程还是一样的。所以重复代码还是很多。 原本想在 UserCaseHandler 里面增加 View 的持有，从而在 UserCaseHandler 进行 CallBack 的时候把 closeloading 和 onSucces，onFail 都写好，这样就可以解决问题了。 这样的设计方案有个弊端，View 层入侵了 UserCaseHandler，耦合度又增加了。所以看实际需求来权衡吧 来来来，上代码 MvpCleanActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142public class MvpCleanActivity extends Activity implements LoginContract.View&lt;BaseResponseValues&gt; &#123; CleanLoginPresenter loginPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); loginPresenter = new CleanLoginPresenter(this, UseCaseHandler.getInstance(), new LoginTask()); loginPresenter.login("111", "111"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); &#125; @Override public void showLoading() &#123; Log.i("MvpCleanActivity", "showloading"); &#125; @Override public void closeLoading() &#123; Log.i("MvpCleanActivity", "closeloading"); &#125; @Override public void onSuccess(BaseResponseValues r) &#123; Log.i("MvpCleanActivity", r.getResult().getMessage()); // will crash String msg = null; msg.toLowerCase(); &#125; @Override public void onFail() &#123; Log.i("MvpCleanActivity", "login fail"); &#125; CleanLoginPresenter.java 12345678910111213141516171819202122232425262728293031323334public class CleanLoginPresenter implements LoginContract.Presenter &#123; private final LoginContract.View mView; private final UseCaseHandler mUseCaseHandler; private final LoginTask loginTask; public CleanLoginPresenter(LoginContract.View mView, UseCaseHandler mUseCaseHandler, LoginTask loginTask) &#123; // TODO 参数过多，使用 builder 模式 this.mView = mView; this.mUseCaseHandler = mUseCaseHandler; this.loginTask = loginTask; &#125; @Override public void login(String uid, String password) &#123; mView.showLoading(); mUseCaseHandler.execute(loginTask, new LoginTask.LoginRequestValues(uid, password), new UseCase.UseCaseCallback&lt;BaseResponseValues&gt;() &#123; @Override public void onSuccess(BaseResponseValues response) &#123; mView.closeLoading(); mView.onSuccess(response); &#125; @Override public void onError() &#123; mView.closeLoading(); mView.onFail(); &#125; &#125;); &#125; LoginTask.java 123456789101112131415161718192021222324252627public class LoginTask extends UseCase&lt;LoginTask.LoginRequestValues, BaseResponseValues&gt; &#123; @Override protected void executeUseCase(LoginRequestValues requestValues) &#123; // TODO 网络请求 // 回调 getUseCaseCallback().onSuccess(new BaseResponseValues( ResponseEntry .Builder() .setStatus(1) .setMessage("Login success"))); &#125; public static final class LoginRequestValues extends BaseRequsetValues &#123; public LoginRequestValues(@NonNull String uid, @NonNull String password) &#123; super(new HashMap&lt;String, String&gt;()); uid = checkNotNull(uid, "task cannot be null!"); password = checkNotNull(password, "task cannot be null!"); getParmas().put("uid", uid); getParmas().put("password", password); &#125; &#125; &#125; LoginTask 里面跟官方还是不一样的，因为实际需求中，请求的参数和返回的结果结构大多数都是一样的，所以 RequestValues 和 ResponseValues 还是可以封装成公用的。 LoginContract.java 123456789101112131415public class LoginContract &#123; public interface View&lt;T&gt; &#123; void showLoading(); void closeLoading(); void onSuccess(T Result); void onFail(); &#125; public interface Presenter &#123; void login(String uid, String password); &#125; &#125; 就像本文所说，View 层可以再封装成 BaseView，把重复的的代码放进去 UserCase相关的就不放出来了，官方已经封装好了，实际上就是封装了一个线程池，用于异步处理 Task，所以直接使用即可。完整代码已经上传到 github上去了 -&gt; https://github.com/rinfon/mvp.git MVP-Dagger 未完待续 MVP-RxJavaRxJava ，之前我一直很抗拒，因为上手感觉很难，另一部分可能自己心燥，静不下来好好研究。但最近看 MVP-clean 的时候有用到，所以也就铁下心来研究了一下。 本来想写篇文章来分享一下的，但后来看到大神们都已经解释的很清楚，连我都能看懂的，我相信你们都能看懂的。 附上链接 ，小水管 RxJava 通过作者的小水管，我相信你们也会喜欢上 RxJava 的。 回到整体 MVP-RxJava，我看了 google 的 demo 之后，发现其实没什么特别的神的地方（应该是没什么出彩的地方），也就是简单版的 MVP 加上 RxJava 而已，所以 demo 就不放出来了。放出关键代码吧 LoginPresenter.Java 123456789101112131415161718192021222324mCompositeDisposable.add(Observable.create(new ObservableOnSubscribe&lt;User&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;User&gt; e) throws Exception &#123; User user = new User(); user.uid = uid; user.password = password; e.onNext(user); e.onComplete(); &#125; &#125;).subscribeOn(mSchedulerProvider.io()) .observeOn(mSchedulerProvider.ui()) .subscribe(new Consumer&lt;User&gt;() &#123; @Override public void accept(User user) throws Exception &#123; mView.closeLoading(); mView.onSuccess(user); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; mView.closeLoading(); mView.onFail(); &#125; &#125;)); 总结 任何架构设计都是为了解耦，而解耦随之带来的就是代码的增加以及重复 设计的过程中，要注意各层的职责，尽量可以避免入侵 在我的 Demo 中，为了处理回调导致的奔溃，我对回调进行了 try catch，这没有问题，但要对详细的异常进行区分，不能所有的异常都吃掉，这是一种不负责的写法（小孩子不要模范啦）有时候，就应该让它 Crash，才知道问题所在。如果非要吃掉所有的异常，也要封装成一个 ErrorCode，对错误信息进行收集。知乎链接，里面有大牛解释的很清楚了。]]></content>
      <tags>
        <tag>MVVM</tag>
        <tag>Android架构</tag>
        <tag>MVP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MWeb 自动发布到 Hexo]]></title>
    <url>%2F2019%2F01%2F15%2FMWeb%20%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E5%88%B0%20Hexo%2F</url>
    <content type="text"><![CDATA[需求之前一直在寻找一个合适的方式来记录工作的日常，例如问题记录、方案计划等等。但一直没有找到一直适合自己的工作流程。主要还是卡在记录这一步骤。 记录。记什么、记在哪里、怎么记。 为了解决记录问题，我尝试过Eventnote、便签、手写笔记本等等。最后发现都因为各种各样的原因让我放弃了。 Eventnote的编辑器、便签的同步问题、手机笔记本的搜索问题都在阻碍着我记录 个人认为一个良好的工作流程应该如下： 接收到需求 计划 实施 记录 归档 配合Alfred实现以下功能 新建文章 查询文章 增加Tag功能 自动发布到某篇文章到Hexo 新建文章查询文章增加Tag功能自动发布某篇文章到Hexo title问题 tag问题 数据库查询 关联mweb hexo问题遇到的问题 alfred 执行git、hexo命令找不到问题]]></content>
      <tags>
        <tag>我</tag>
        <tag>git</tag>
        <tag>新增的tag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android studio Jar 包制作以及混淆]]></title>
    <url>%2F2019%2F01%2F12%2F2019-01-12-android%20studio%20Jar%20%E5%8C%85%E5%88%B6%E4%BD%9C%E4%BB%A5%E5%8F%8A%E6%B7%B7%E6%B7%86%2F</url>
    <content type="text"><![CDATA[需求 项目越来越大，需要对核心代码进行封装加密管理 Jar 包制作 优点：简单，方便 缺点：不能把资源文件都打进去 Jar 包里面，例如图片，布局文件等等 aar 制作 优点：跟 Jar 一样，可以把资源文件都打包进去，AS可以直接引用，管理方便 缺点：- so 制作 优点：增加反编译难度，核定代码可以放进去 缺点：需要 C/C++基础，并不是所有都适合放到 so 里面去。 实现制作 新建一个 module，选择 Android Library Finish 把你需要封装的代码写在 module 里面去 打包 在 module 里面的 build.gradle 文件加入一下 Task 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748task buildJar(type: Jar, dependsOn: ['compileReleaseJavaWithJavac']) &#123; // task buildJar(type: Jar, dependsOn: ['build'])// 导出的 jar 文件的名称 archiveName = "testJar-debug.jar" //需打包的资源所在的路径集 from('build/intermediates/classes/release') destinationDir = file('../libs') // //导出的 jar 文件的存放目录（未指定则默认存放在 build/libs 下） destinationDir = file('D:/libs') exclude "**/BuildConfig.class" //去掉不要的类 exclude('**/R.class') exclude('**/R\$*.class') include "**/*.*" //需要打包的类 如 // include('com/reginer/mytest/*.class')&#125;task proguardJar(dependsOn: ['buildJar'], type: ProGuardTask) &#123; println('proguard '+project.name+' jar') //Android 默认的 proguard 文件 configuration android.getDefaultProguardFile('proguard-android.txt') //加载各模块 proguard 配置文件 configuration 'proguard-rules.pro' String inJar = buildJar.archivePath.getAbsolutePath() injars inJar outjars inJar.substring(0, inJar.lastIndexOf('-')) + "-release.jar" //设置不删除未引用的资源(类，方法等) dontshrink //运行时 jar 包不混淆 Plugin plugin = getPlugins().hasPlugin(AppPlugin) ? getPlugins().findPlugin(AppPlugin) : getPlugins().findPlugin(LibraryPlugin) if (plugin != null) &#123; List&lt;String&gt; runtimeJarList if (plugin.getMetaClass().getMetaMethod("getRuntimeJarList")) &#123; runtimeJarList = plugin.getRuntimeJarList() &#125; else if (android.getMetaClass().getMetaMethod("getBootClasspath")) &#123; runtimeJarList = android.getBootClasspath() &#125; else &#123; runtimeJarList = plugin.getBootClasspath() &#125; for (String runtimeJar : runtimeJarList) &#123; libraryjars(runtimeJar) &#125; &#125;&#125; 打开 Gradle 任务，执行 buildJar 然后再执行 proguardJar 任务进行混淆 最后你会发现在项目中出现 test-relase.jar 注意buildJar里面archiveName名字必须有-，不然会执行错误的。原因在与在混淆的时候，需要把包名改成 relase.不喜欢的可以自行修改逻辑代码 注意buildJar里面archiveName名字必须有-，不然会执行错误的。原因在与在混淆的时候，需要把包名改成 relase.不喜欢的可以自行修改逻辑代码 注意buildJar里面archiveName名字必须有-，不然会执行错误的。原因在与在混淆的时候，需要把包名改成 relase.不喜欢的可以自行修改逻辑代码]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 项目架构之 MVP]]></title>
    <url>%2F2019%2F01%2F11%2F2019-01-11-Android%20%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E4%B9%8B%20MVP%2F</url>
    <content type="text"><![CDATA[需求本文不是学术文字讨论（复制粘贴）文，所以不会详细解释什么叫 MVP，MVC，Dagger，Clean 等等。主要以实际项目为基础，简单的实现登录功能。 当代码量越来越大，需要对已有的代码进行整理以及重构，实现解耦. 无论任何的架构模式以及设计模式都是为了代码解耦 研究方向MVP 模式： Model:数据层，主要负责网络数据请求与获取，数据库的处理等等数据相关的逻辑处理 View:视图层，显示数据，例如 Activity,Fragment,View 等等 UI 载体 Presenter:代理层, View 逻辑处理的集合，并且将 Model 获取的数据返回给 View 层 MVP 类型 MVP 简单版 MVP-Clean主要参考实现 Clean Architecture. MVP-DaggerDragger2 的 MVP 实现 MVP-RxJavaRxJava 的 MVP 实现MVP 的简单实现逻辑图 ViewUI 的展示 BasePresenterImpl封装了 View 的处理流程，数据回调等等，例如进行网络请求的时候，loading 的显示与隐藏。 LoginPresenter登录逻辑处理的地方 BaseRespository封装了异常处理，例如网络请求回调的时候，页面消失了，这时候再进行 ui 处理的话就会奔溃。为了不每个页面都加上判空处理，所以就封装了一层。如不需要可以去掉这一层 LoginRespository登录真正执行的地方 关键代码 MainActivity.java 1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends Activity implements IBaseView&lt;String&gt; &#123; LoginPresenter loginPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); loginPresenter = new LoginPresenter(this); loginPresenter.toLogin("111", "111"); &#125; @Override protected void onDestroy() &#123; loginPresenter.unBind(); super.onDestroy(); &#125; @Override public void onSuccess(String Result) &#123; Log.i("MainActivity", Result); &#125; @Override public void onFailed(ErrorCode errorCode) &#123; Log.i("MainActivity", errorCode.getMessage()); String msg = null; msg.toLowerCase(); &#125; @Override public void showProgress() &#123; Log.i("MainActivity", "loading"); &#125; @Override public void hideProgress() &#123; Log.i("MainActivity", "hide loading"); &#125; &#125; LoginPresenter.java 123456789101112131415public class LoginPresenter extends BasePresenterImpl &#123; IBaseRepository baseRepository; public LoginPresenter(IBaseView mView) &#123; super(mView); &#125; public void toLogin(String uid, String password) &#123; mView.showProgress(); baseRepository = LoginRepository.Builder(baseCallback) .setUid(uid).setPassword(password); baseRepository.Action(); &#125; &#125; LoginRepository.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class LoginRepository extends BaseRepository implements IBaseRepository &#123; private String uid; private String password; public static LoginRepository Builder(BaseInteractor.Callback callback) &#123; return new LoginRepository(callback); &#125; public String getUid() &#123; return uid; &#125; public LoginRepository setUid(String uid) &#123; this.uid = uid; return this; &#125; public String getPassword() &#123; return password; &#125; public LoginRepository setPassword(String password) &#123; this.password = password; return this; &#125; public LoginRepository(BaseInteractor.Callback callback) &#123; super(callback); &#125; @Override public void Action() &#123; // TODO // 网络请求 // onRequsetSuccess("login success"); onRequestFailed(new ErrorCode().setStatus(0).setMessage("login fail")); &#125; @Override public void Cancel() &#123; // TODO // 取消网络请求 // 回调上一次进行异常处理 onCancel(); &#125; &#125; 完整代码已经上传到github上去了 -&gt; https://github.com/rinfon/mvp.git MVP-Clean逻辑图 Clean 架构图 时序图就像这篇文章Android 官方架构项目之 MVP + Clean 所说，clean 架构比简单版的 MVP 就是多了一层 Domain 层，减轻 Presenter 的负担。 关键代码 在研究官方的Demo中，有些地方还是值得斟酌的 View 层不通用，例如有些 loading，onSuccess，onError 等通用函数应该抽象到 BaseView 里面去，减少代码量 所有的 Task 都在一开始就在界面初始化好了，如果有些功能我没有用到，那么就浪费资源了，应该改成需要用到的时候再初始化 在 presenter 初始化的时候，View 层传的参数太多了。例如 View 层所有的 task 都要初始化好传进去。个人认为这是不科学的。但后来想官方这样写的原因是为了区分 View 与 Presenter 的职责（看来我还是太年轻了），View 作为数据的提供者，Presenter 作为数据的接受者。所以才不在 Presenter 层新建数据。既然如此，那只需要 Builder 模式就可以解决参数过多的问题了。 Presenter 层 callback 重复代码过多，例如 123456789101112131415mUseCaseHandler.execute(loginTask, new LoginTask.LoginRequestValues(uid, password), new UseCase.UseCaseCallback&lt;BaseResponseValues&gt;() &#123; @Override public void onSuccess(BaseResponseValues response) &#123; mView.closeLoading(); mView.onSuccess(response); &#125; @Override public void onError() &#123; mView.closeLoading(); mView.onFail(); &#125; &#125;); 每次 excute 都需要提供一个 callback，而每个 callback 仅仅 response 的类型不一样而已。流程还是一样的。所以重复代码还是很多。 原本想在 UserCaseHandler 里面增加 View 的持有，从而在 UserCaseHandler 进行 CallBack 的时候把 closeloading 和 onSucces，onFail 都写好，这样就可以解决问题了。 这样的设计方案有个弊端，View 层入侵了 UserCaseHandler，耦合度又增加了。所以看实际需求来权衡吧 来来来，上代码 MvpCleanActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142public class MvpCleanActivity extends Activity implements LoginContract.View&lt;BaseResponseValues&gt; &#123; CleanLoginPresenter loginPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); loginPresenter = new CleanLoginPresenter(this, UseCaseHandler.getInstance(), new LoginTask()); loginPresenter.login("111", "111"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); &#125; @Override public void showLoading() &#123; Log.i("MvpCleanActivity", "showloading"); &#125; @Override public void closeLoading() &#123; Log.i("MvpCleanActivity", "closeloading"); &#125; @Override public void onSuccess(BaseResponseValues r) &#123; Log.i("MvpCleanActivity", r.getResult().getMessage()); // will crash String msg = null; msg.toLowerCase(); &#125; @Override public void onFail() &#123; Log.i("MvpCleanActivity", "login fail"); &#125; CleanLoginPresenter.java 12345678910111213141516171819202122232425262728293031323334public class CleanLoginPresenter implements LoginContract.Presenter &#123; private final LoginContract.View mView; private final UseCaseHandler mUseCaseHandler; private final LoginTask loginTask; public CleanLoginPresenter(LoginContract.View mView, UseCaseHandler mUseCaseHandler, LoginTask loginTask) &#123; // TODO 参数过多，使用 builder 模式 this.mView = mView; this.mUseCaseHandler = mUseCaseHandler; this.loginTask = loginTask; &#125; @Override public void login(String uid, String password) &#123; mView.showLoading(); mUseCaseHandler.execute(loginTask, new LoginTask.LoginRequestValues(uid, password), new UseCase.UseCaseCallback&lt;BaseResponseValues&gt;() &#123; @Override public void onSuccess(BaseResponseValues response) &#123; mView.closeLoading(); mView.onSuccess(response); &#125; @Override public void onError() &#123; mView.closeLoading(); mView.onFail(); &#125; &#125;); &#125; LoginTask.java 123456789101112131415161718192021222324252627public class LoginTask extends UseCase&lt;LoginTask.LoginRequestValues, BaseResponseValues&gt; &#123; @Override protected void executeUseCase(LoginRequestValues requestValues) &#123; // TODO 网络请求 // 回调 getUseCaseCallback().onSuccess(new BaseResponseValues( ResponseEntry .Builder() .setStatus(1) .setMessage("Login success"))); &#125; public static final class LoginRequestValues extends BaseRequsetValues &#123; public LoginRequestValues(@NonNull String uid, @NonNull String password) &#123; super(new HashMap&lt;String, String&gt;()); uid = checkNotNull(uid, "task cannot be null!"); password = checkNotNull(password, "task cannot be null!"); getParmas().put("uid", uid); getParmas().put("password", password); &#125; &#125; &#125; LoginTask 里面跟官方还是不一样的，因为实际需求中，请求的参数和返回的结果结构大多数都是一样的，所以 RequestValues 和 ResponseValues 还是可以封装成公用的。 LoginContract.java 123456789101112131415public class LoginContract &#123; public interface View&lt;T&gt; &#123; void showLoading(); void closeLoading(); void onSuccess(T Result); void onFail(); &#125; public interface Presenter &#123; void login(String uid, String password); &#125; &#125; 就像本文所说，View 层可以再封装成 BaseView，把重复的的代码放进去 UserCase相关的就不放出来了，官方已经封装好了，实际上就是封装了一个线程池，用于异步处理 Task，所以直接使用即可。完整代码已经上传到 github上去了 -&gt; https://github.com/rinfon/mvp.git MVP-Dagger 未完待续 MVP-RxJavaRxJava ，之前我一直很抗拒，因为上手感觉很难，另一部分可能自己心燥，静不下来好好研究。但最近看 MVP-clean 的时候有用到，所以也就铁下心来研究了一下。 本来想写篇文章来分享一下的，但后来看到大神们都已经解释的很清楚，连我都能看懂的，我相信你们都能看懂的。 附上链接 ，小水管 RxJava 通过作者的小水管，我相信你们也会喜欢上 RxJava 的。 回到整体 MVP-RxJava，我看了 google 的 demo 之后，发现其实没什么特别的神的地方（应该是没什么出彩的地方），也就是简单版的 MVP 加上 RxJava 而已，所以 demo 就不放出来了。放出关键代码吧 LoginPresenter.Java 123456789101112131415161718192021222324mCompositeDisposable.add(Observable.create(new ObservableOnSubscribe&lt;User&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;User&gt; e) throws Exception &#123; User user = new User(); user.uid = uid; user.password = password; e.onNext(user); e.onComplete(); &#125; &#125;).subscribeOn(mSchedulerProvider.io()) .observeOn(mSchedulerProvider.ui()) .subscribe(new Consumer&lt;User&gt;() &#123; @Override public void accept(User user) throws Exception &#123; mView.closeLoading(); mView.onSuccess(user); &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Exception &#123; mView.closeLoading(); mView.onFail(); &#125; &#125;)); 总结 任何架构设计都是为了解耦，而解耦随之带来的就是代码的增加以及重复 设计的过程中，要注意各层的职责，尽量可以避免入侵 在我的 Demo 中，为了处理回调导致的奔溃，我对回调进行了 try catch，这没有问题，但要对详细的异常进行区分，不能所有的异常都吃掉，这是一种不负责的写法（小孩子不要模范啦）有时候，就应该让它 Crash，才知道问题所在。如果非要吃掉所有的异常，也要封装成一个 ErrorCode，对错误信息进行收集。知乎链接，里面有大牛解释的很清楚了。]]></content>
      <tags>
        <tag>MPV</tag>
        <tag>MVVM</tag>
        <tag>Android架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 found an invalid color]]></title>
    <url>%2F2019%2F01%2F11%2F2019-01-11-%E8%A7%A3%E5%86%B3%20found%20an%20invalid%20color%2F</url>
    <content type="text"><![CDATA[问题在导入 eclipse 项目的时候，有时候会出现 found an invalid color 这个问题，原因在于 AS 对.9 图片的检查 解决方法 图片是.9.png 格式的，但是没有画黑色边框线，需要画上边框线，保存就可以了。或者直接把.9 格式去掉即可]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 的简单介绍]]></title>
    <url>%2F2019%2F01%2F11%2F2019-01-11-git%20%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[git 的简单介绍是什么? Git 是目前世界上最先进的分布式版本控制系统。 为什么 适合分布式开发 速度快，灵活 优秀的解决冲突能力 版本管理 工作流程 克隆项目 修改项目 提交更改 拉取远端最新的更改（如果别人在你修改期间有更改推送过，则需要拉取） 如本地修改跟远端修改有冲突，则解决冲突 重新提交 推送远端 对应流程图如下： 常用命令 git init用于初始化项目 git clone用于克隆项目 git add添加修改文件。其中 git add .代表添加所有修改过的问题件，git add 文件路径,代表添加特定的文件。 git commit提交更改日志，例如 git commit -m “增加功能” git fetch检查远端是否有更改 git pull拉取远端的最新的代码，例如 git pull –rebase.rebase 和 merge 的区别在于：merge 操作会生成一个新的节点，之前的提交分开显示。而 rebase 操作不会生成新的节点，是将两个分支融合成一个线性的提交。所以我们通常 git pull 都会加上 rebase 的参数 git push推送本地更改到服务器,例如 git push orgin master git branch查看当前分支,而如果加上-r 参数，代表查看远程分支 git branch -r git checkout切换分支 例如，git checkout -b develop，切换到 develop 分支，如果本地已经有 develop 分支，则 git checkout develop git tag为节点打日志，例如，我们要为 1b2e1d63ff 打上 1.0 的标签:git tag 1.0 1b2e1d63ff git reset丢弃所有的本地所有的更改，git reset HEAD –hard,同时也可以用此命令回到之前的节点，如果我要返回到上一个节点（注意，此返回指的是你本地返回，而不是远端返回），git reset HEAD^ –hard git status查看本地缓存修改记录 常用技巧现在有 a、b、c、d、e，5 个提交点，我需要切换回滚到 c 节点，丢弃的 d,e 节点git reset HEAD^^ --hard（或者 git reset c 点的 sha 码 --hard） git push origin HEAD --force 把别的分支某个提交点提交到当前分支 例如 develop 上有提交点 a(sha 码为 1b2e1d63ff),需要把 a 也提交到 master 上去. git checkout master git cherry-pick -x 1b2e1d63ff,-x 代表着保留原始作者信息 如果途中产生冲突，则按照标准的解决冲突方法去解决。然后重新 commit 即可 查找某个文件的某行修改记录 新接手了一个项目，里面某一行代码不知道为什么原作者这样写，需要查看对应的提交点记录才能知道为啥当初这样写 例如要查看 a.java 文件的修改记录 git blame **/a.java(注意文件路径),得到如下结果 12345678910^5cdd7bd (Rinfon 2018-04-02 13:14:34 +0800 68) LocalTextView apStepBack;^5cdd7bd (Rinfon 2018-04-02 13:14:34 +0800 69) @BindView(R.id.ap_step_next)^5cdd7bd (Rinfon 2018-04-02 13:14:34 +0800 70) LocalTextView apStepNext;20997902 (Rinfon 2018-06-25 12:03:13 +0800 71) @BindView(R.id.ap_step_three_icon)20997902 (Rinfon 2018-06-25 12:03:13 +0800 72) ImageView apStepThreeIcon;20997902 (Rinfon 2018-06-25 12:03:13 +0800 73) @BindView(R.id.wifi_remember)20997902 (Rinfon 2018-06-25 12:03:13 +0800 74) CheckBox wifiRemember;20997902 (Rinfon 2018-06-25 12:03:13 +0800 75) @BindView(R.id.ap_step_btn_layout)20997902 (Rinfon 2018-06-25 12:03:13 +0800 76) LinearLayout apStepBtnLayout;^5cdd7bd (Rinfon 2018-04-02 13:14:34 +0800 77) private Unbinder unbinder; 这时候已经得到了 sha 码，就可以通过 git show 20997902,可以得到修改的信息。 分支管理主要分支 master 分支。仅且只有一个主分支，用于提供正式版本 develop 分支，开发分支，用于日常开发，如果一个版本开发完整，测试通过，则合并到 develop 里面去。合并的时候需要加上 –no-ff，快进式合并，保证版本的演进清晰。临时分支 feature 分支，当需要做一个新功能时，需要基于 develop 开一个 feature 分支，即使 feature 不完成，也不会影响 develop 的进度. hotfix 分支，用于修改 bug 的分支，基于 master 分出来的。修改结束后，合并到 master 和 develop 上去 但这只是一个基础想法，并不是适用于所有的项目的，而我们需要做的，就是对此策略加以修改，变成适合自己的分支管理。]]></content>
  </entry>
</search>
